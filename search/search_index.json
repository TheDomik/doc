{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"Home"},{"location":"getting-started/","text":"Getting Started \u00b6 This is a Domik - a tool for houses creation. It uses a visual scripting system to determine a logic of generation and designed to work with modular building systems. Highlights \u00b6 Generation of room interiors with furniture . Powerful visual scripting system - The Pipeline . Supports of third party assets. Seed number based generation, feel free to integrate it with your own procedural worlds. Supports of all types of gameobjects , so you can place something like a spawn-point right in a house. Just use a furniture system . In-Editor Generation. Runtime Generation. Multiple floors . Stairs . Mesh combine system is built-in. 2D Assets support (example is not included yet). Mobile , Consoles , WebGL and PC are supported. HDRP , URP and Built-in scriptable pipeline are supported. Tutorials \u00b6 how to create a procedural house how to change a house size how to change house floors how the domik builds a house how to change room walls how to replace models or materials how to add new stuff what is a part builder space how to create and use a placeable object how to create a place facades workflow how to create a preview system how to create and use the pipeline deep dive into house building process Main Concepts \u00b6 house generator preview system part part builder skin palette palettes random container place mask placeable object placeable objects container floor interior floor tag pipeline Pipeline Nodes \u00b6 Action: extract positions find and replace shift Add: add part Filter: filter by mask filter by positions filter by floor tag filter floor filter internal doors places filter intersections filter neighbor cells filter random cells filter random input filter with part filter with parts filter without part Flow: exclude merge override shuffle Interiors: calculate room interiors place furniture return interiors split into rooms Main: end start Place: place part by mask for all rotations place placeable object forced place placeable object place stairs Remove: apply parts removing remove part remove part later Skins: create skins layer override skins layer return skins layer","title":"getting started"},{"location":"getting-started/#getting-started","text":"This is a Domik - a tool for houses creation. It uses a visual scripting system to determine a logic of generation and designed to work with modular building systems.","title":"Getting Started"},{"location":"getting-started/#highlights","text":"Generation of room interiors with furniture . Powerful visual scripting system - The Pipeline . Supports of third party assets. Seed number based generation, feel free to integrate it with your own procedural worlds. Supports of all types of gameobjects , so you can place something like a spawn-point right in a house. Just use a furniture system . In-Editor Generation. Runtime Generation. Multiple floors . Stairs . Mesh combine system is built-in. 2D Assets support (example is not included yet). Mobile , Consoles , WebGL and PC are supported. HDRP , URP and Built-in scriptable pipeline are supported.","title":"Highlights"},{"location":"getting-started/#tutorials","text":"how to create a procedural house how to change a house size how to change house floors how the domik builds a house how to change room walls how to replace models or materials how to add new stuff what is a part builder space how to create and use a placeable object how to create a place facades workflow how to create a preview system how to create and use the pipeline deep dive into house building process","title":"Tutorials"},{"location":"getting-started/#main-concepts","text":"house generator preview system part part builder skin palette palettes random container place mask placeable object placeable objects container floor interior floor tag pipeline","title":"Main Concepts"},{"location":"getting-started/#pipeline-nodes","text":"Action: extract positions find and replace shift Add: add part Filter: filter by mask filter by positions filter by floor tag filter floor filter internal doors places filter intersections filter neighbor cells filter random cells filter random input filter with part filter with parts filter without part Flow: exclude merge override shuffle Interiors: calculate room interiors place furniture return interiors split into rooms Main: end start Place: place part by mask for all rotations place placeable object forced place placeable object place stairs Remove: apply parts removing remove part remove part later Skins: create skins layer override skins layer return skins layer","title":"Pipeline Nodes"},{"location":"main-concepts/floor-tag/","text":"Floor Tag \u00b6 The Floor Tag is a tag that you can add to the floor to divide it from others. Here's the idea: you have to add a tag to the floor that you want to change in some specific manner to process it later in the pipeline by filtering this floor with a filter by floor tag node . How to create a Floor Tag? To create a floor tag right click on some folder -> Create -> Domik -> Floor Tag . Floor Tag Floor Tags in the Floor","title":"floor tag"},{"location":"main-concepts/floor-tag/#floor-tag","text":"The Floor Tag is a tag that you can add to the floor to divide it from others. Here's the idea: you have to add a tag to the floor that you want to change in some specific manner to process it later in the pipeline by filtering this floor with a filter by floor tag node . How to create a Floor Tag? To create a floor tag right click on some folder -> Create -> Domik -> Floor Tag . Floor Tag Floor Tags in the Floor","title":"Floor Tag"},{"location":"main-concepts/floor/","text":"Floor \u00b6 The Floor is a description of the house floor. A list of floors of the house stored in the house generator . Flex checkbox - set it true if this floor can be duplicated to fit the target floors count. Interiors list - a list of interiors that can be in this floor . Floor Tags list - a list of floor tags that describes this floor in some manner to make you able to filter floors in the Pipeline by the filter by floor tag node. See also: floor tag , how to change house floors .","title":"floor"},{"location":"main-concepts/floor/#floor","text":"The Floor is a description of the house floor. A list of floors of the house stored in the house generator . Flex checkbox - set it true if this floor can be duplicated to fit the target floors count. Interiors list - a list of interiors that can be in this floor . Floor Tags list - a list of floor tags that describes this floor in some manner to make you able to filter floors in the Pipeline by the filter by floor tag node. See also: floor tag , how to change house floors .","title":"Floor"},{"location":"main-concepts/house-generator/","text":"House Generator \u00b6 The House Generator component is an entry point to start generation of the house. This component provides a setting and construction of the house, and it's designed as a standalone component without any references to editor, so you can just duplicate it, wrap it to a prefab or doing something else. Read More: how to create a procedural house . Generate section \u00b6 Generate Random - click it to generate a house with a random seed . Seed - a seed number which uses to generate a house. Read More . Generate - click it to generate a house from the current seed number. Pretty useful to regenerate a house after some changes to see a difference. Pipeline - a reference to the Pipeline Node Graph asset. If you want to change rules of generation you, have to change it. Combining Mode - defines how meshes of the house should be combined: Realtime - Fast. Vertices welding and normals recalculation are disabled, so expect some artefacts on seams between flat meshes (walls, floor, ceiling etc.). The backed lighting also will be broken. Good choice for rogue-like games or to fast check some changes, btw. Baked - very slow but artefacts free. Good choice for final creating of the house. Can be used in realtime too, but it can be too slow for it. Base Size section \u00b6 This panel defines the target size of the house. Width - target width of the house. Length - target length of the house. Floors - target floors count. You can select between two size modes: const and rand . Const - constant size. Rand - random size. Why the final size may differ than the target size? These values not using directly, but send to the Pipeline , so the final size of the house depends on the Pipeline algorithm. Read More: how to change a house size . House Skins section \u00b6 This is a list of base house skins. You can think about these skins as about skins by default. Read More: facades workflow , skin . Floors section \u00b6 Floors - is a description of floors that you expect to see. Read More: how to change house floors .","title":"house generator"},{"location":"main-concepts/house-generator/#house-generator","text":"The House Generator component is an entry point to start generation of the house. This component provides a setting and construction of the house, and it's designed as a standalone component without any references to editor, so you can just duplicate it, wrap it to a prefab or doing something else. Read More: how to create a procedural house .","title":"House Generator"},{"location":"main-concepts/house-generator/#generate-section","text":"Generate Random - click it to generate a house with a random seed . Seed - a seed number which uses to generate a house. Read More . Generate - click it to generate a house from the current seed number. Pretty useful to regenerate a house after some changes to see a difference. Pipeline - a reference to the Pipeline Node Graph asset. If you want to change rules of generation you, have to change it. Combining Mode - defines how meshes of the house should be combined: Realtime - Fast. Vertices welding and normals recalculation are disabled, so expect some artefacts on seams between flat meshes (walls, floor, ceiling etc.). The backed lighting also will be broken. Good choice for rogue-like games or to fast check some changes, btw. Baked - very slow but artefacts free. Good choice for final creating of the house. Can be used in realtime too, but it can be too slow for it.","title":"Generate section"},{"location":"main-concepts/house-generator/#base-size-section","text":"This panel defines the target size of the house. Width - target width of the house. Length - target length of the house. Floors - target floors count. You can select between two size modes: const and rand . Const - constant size. Rand - random size. Why the final size may differ than the target size? These values not using directly, but send to the Pipeline , so the final size of the house depends on the Pipeline algorithm. Read More: how to change a house size .","title":"Base Size section"},{"location":"main-concepts/house-generator/#house-skins-section","text":"This is a list of base house skins. You can think about these skins as about skins by default. Read More: facades workflow , skin .","title":"House Skins section"},{"location":"main-concepts/house-generator/#floors-section","text":"Floors - is a description of floors that you expect to see. Read More: how to change house floors .","title":"Floors section"},{"location":"main-concepts/interior/","text":"Interior \u00b6 The Interior is a description of the room. It answers three questions: How should it look like? Where should it be? That furniture should be there? How to create an interior? To create an interior select some folder in the Project window -> Right Mouse Click -> Create -> Domik -> Interior Furniture \u00b6 This is a list of placeable objects that you want to place in the room. You can use a placeable object or a placeable objects container here. Skins \u00b6 This is a list of skins which defines how a room should look like. Top items of the list have higher priority than bottom, so you can override bottom skins with top skins . Interior skins have higher priority than house generator skins . You can use a skin , palette or a palettes random container here. Placing Rules \u00b6 This panel describes a room that can be used with this interior . Max Count Per Floor - a limit of using this interior per floor. Example: bathroom. Zero number means that you don't want to use a limit for this interior . Prefer Room - a preferred size for a room: Small - small rooms better. Middle - middle size rooms better. Big - big rooms better. Random - you don't care. Parts Limit list - a list of parts which should or shouldn't be it the room. Parts Limit list item \u00b6 Part field - a part that you want to limit. Mode - a type of limit. Fixed - limit a count of this part in the room by the concrete number. Range - limit a count of this part in the room by the range. At Least One - this part should be at least in one exemplar in the room. Unacceptable - This part shouldn't be in the room. See Also: part , how-to change room walls , house generator .","title":"interior"},{"location":"main-concepts/interior/#interior","text":"The Interior is a description of the room. It answers three questions: How should it look like? Where should it be? That furniture should be there? How to create an interior? To create an interior select some folder in the Project window -> Right Mouse Click -> Create -> Domik -> Interior","title":"Interior"},{"location":"main-concepts/interior/#furniture","text":"This is a list of placeable objects that you want to place in the room. You can use a placeable object or a placeable objects container here.","title":"Furniture"},{"location":"main-concepts/interior/#skins","text":"This is a list of skins which defines how a room should look like. Top items of the list have higher priority than bottom, so you can override bottom skins with top skins . Interior skins have higher priority than house generator skins . You can use a skin , palette or a palettes random container here.","title":"Skins"},{"location":"main-concepts/interior/#placing-rules","text":"This panel describes a room that can be used with this interior . Max Count Per Floor - a limit of using this interior per floor. Example: bathroom. Zero number means that you don't want to use a limit for this interior . Prefer Room - a preferred size for a room: Small - small rooms better. Middle - middle size rooms better. Big - big rooms better. Random - you don't care. Parts Limit list - a list of parts which should or shouldn't be it the room.","title":"Placing Rules"},{"location":"main-concepts/interior/#parts-limit-list-item","text":"Part field - a part that you want to limit. Mode - a type of limit. Fixed - limit a count of this part in the room by the concrete number. Range - limit a count of this part in the room by the range. At Least One - this part should be at least in one exemplar in the room. Unacceptable - This part shouldn't be in the room. See Also: part , how-to change room walls , house generator .","title":"Parts Limit list item"},{"location":"main-concepts/mask/","text":"Mask \u00b6 The Mask - is a mask of adjacency of cells . This is a description of some place, but in terms of accessibility from the target cell . Mostly useful in situations when you want to find borders of rooms or whole house. How to create a mask? To create new floor select some folder in the Project window -> Right Mouse Click -> Create -> Domik -> Mask Space - what type of accessibility do you want to check? House - you want to check that the neighbouring cells belong to the house (you want to find borders of house). Rooms - you want to check that the neighbouring cells belong to target cell's room (you want to find borders of room). Floor - a floor where you want to edit cells to check. To start working with cells select some cell in the grid. State - select what you expect from this cell: Not Important - you don't want to check this cell. Accessible - This cell should be belonged to the same room as a target cell if you selected the Rooms space or this cell should be belonged to the house if you selected the House space . Inaccessible - this cell should be belonged to another room or doesn't exist at all if you selected the Room space or this cell shouldn't exist in this house if you selected the House space . You can see changes of the mask by the preview system . .","title":"mask"},{"location":"main-concepts/mask/#mask","text":"The Mask - is a mask of adjacency of cells . This is a description of some place, but in terms of accessibility from the target cell . Mostly useful in situations when you want to find borders of rooms or whole house. How to create a mask? To create new floor select some folder in the Project window -> Right Mouse Click -> Create -> Domik -> Mask Space - what type of accessibility do you want to check? House - you want to check that the neighbouring cells belong to the house (you want to find borders of house). Rooms - you want to check that the neighbouring cells belong to target cell's room (you want to find borders of room). Floor - a floor where you want to edit cells to check. To start working with cells select some cell in the grid. State - select what you expect from this cell: Not Important - you don't want to check this cell. Accessible - This cell should be belonged to the same room as a target cell if you selected the Rooms space or this cell should be belonged to the house if you selected the House space . Inaccessible - this cell should be belonged to another room or doesn't exist at all if you selected the Room space or this cell shouldn't exist in this house if you selected the House space . You can see changes of the mask by the preview system . .","title":"Mask"},{"location":"main-concepts/palette/","text":"Palette","title":"palette"},{"location":"main-concepts/palettes-random-container/","text":"","title":"palettes random container"},{"location":"main-concepts/part-builder/","text":"Part Builder \u00b6 The Part Builder is a component which builds a part . If you want to change a look of the part , you have to change its Part Builder . Part Builders are stored in the skin - a prefab with the Skin component in the root. The skin binds parts and part builders together. The skin will try to bind a Part Builder object with four rotated parts if you'll add an [auto] prefix in the name. Part Builder component Part Builder object in the Skin Part Binding in the skin Own Part - link to an automatically bound part. This is just a debug information. Combine - do you want to combine meshes after building? Space - select the building space: Room - build it into the room space. Floor - build it into the floor space. House - build it to the house space. See also: part , skin , how to add new stuff , how to replace models or materials , how to change room walls .","title":"part builder"},{"location":"main-concepts/part-builder/#part-builder","text":"The Part Builder is a component which builds a part . If you want to change a look of the part , you have to change its Part Builder . Part Builders are stored in the skin - a prefab with the Skin component in the root. The skin binds parts and part builders together. The skin will try to bind a Part Builder object with four rotated parts if you'll add an [auto] prefix in the name. Part Builder component Part Builder object in the Skin Part Binding in the skin Own Part - link to an automatically bound part. This is just a debug information. Combine - do you want to combine meshes after building? Space - select the building space: Room - build it into the room space. Floor - build it into the floor space. House - build it to the house space. See also: part , skin , how to add new stuff , how to replace models or materials , how to change room walls .","title":"Part Builder"},{"location":"main-concepts/part/","text":"Part \u00b6 The Part - is a scriptable object which represents an abstract idea of some house object. It's just the name of something that you expect to see in the house, nothing more. The pipeline works only with parts and knows nothing about how parts actually look. A look of the part defines in the skin Part with rotations Rotation degrees written in square brackets Part without rotations Rotation degrees written in square brackets Turned 90 - link to the same part but rotated by 90 degrees. Turned 180 - link to the same part but rotated by 180 degrees. Turned 270 - link to the same part but rotated by 270 degrees. See Also: how the domik builds a house , how to add new stuff , deep dive into house building process .","title":"part"},{"location":"main-concepts/part/#part","text":"The Part - is a scriptable object which represents an abstract idea of some house object. It's just the name of something that you expect to see in the house, nothing more. The pipeline works only with parts and knows nothing about how parts actually look. A look of the part defines in the skin Part with rotations Rotation degrees written in square brackets Part without rotations Rotation degrees written in square brackets Turned 90 - link to the same part but rotated by 90 degrees. Turned 180 - link to the same part but rotated by 180 degrees. Turned 270 - link to the same part but rotated by 270 degrees. See Also: how the domik builds a house , how to add new stuff , deep dive into house building process .","title":"Part"},{"location":"main-concepts/pipeline/","text":"Pipeline \u00b6 The Pipeline is a visual scripting language which uses to generate a house. To create a new instance of Pipeline right click on some folder -> Create -> Domik -> Pipeline. To open some existed Pipeline just double click to it. In pipeline you describes a process of house generation step-by-step. The pipeline consists of nodes. Every node is a step of generation of house. In most cases typical node has two pines: - In - Input cells. - Out - output cells. Node get cells from Input, process them and returns to Output. Sometimes it contains parameters. Every pipeline instance should have at least two nodes: Start Node and End Node. Start Node gets an info from house generator and constructs raw cells. End Node returns processed nodes to the House Builder. Here is an example of primitive pipeline. Start Node - creates a set of nodes based an info from the house generator . Add Parts Node - adds Floor part and Ceiling part to all cells from input. End node - returns input cells with floors and ceilings to the House Builder. To get more information about possible nodes read nodes description below:","title":"pipeline"},{"location":"main-concepts/pipeline/#pipeline","text":"The Pipeline is a visual scripting language which uses to generate a house. To create a new instance of Pipeline right click on some folder -> Create -> Domik -> Pipeline. To open some existed Pipeline just double click to it. In pipeline you describes a process of house generation step-by-step. The pipeline consists of nodes. Every node is a step of generation of house. In most cases typical node has two pines: - In - Input cells. - Out - output cells. Node get cells from Input, process them and returns to Output. Sometimes it contains parameters. Every pipeline instance should have at least two nodes: Start Node and End Node. Start Node gets an info from house generator and constructs raw cells. End Node returns processed nodes to the House Builder. Here is an example of primitive pipeline. Start Node - creates a set of nodes based an info from the house generator . Add Parts Node - adds Floor part and Ceiling part to all cells from input. End node - returns input cells with floors and ceilings to the House Builder. To get more information about possible nodes read nodes description below:","title":"Pipeline"},{"location":"main-concepts/place/","text":"Place \u00b6 The Place is a description of an environment of the cell . Useful to filter cells which fit to place some part or to process some other way. To create a place , select some folder in the Project window -> Right Mouse Click -> Create -> Domik -> Place . Parts \u00b6 This is a section to describe an environment of the cell . Floor - a floor where you want to edit environment cells . Top - edit cells on the floor above. Current - edit cells on the same floor as the cell to checking. Down - edit cells on the floor below. Grid - the grid of environment cells . Click on some to start working with this cell . Enable checkbox - set it true if you this cell is a part of the place that you want to find. Parts list - a list of parts that you expect to see in this cell . The Place works better with the Preview system , every change that you make can be rendered by the Preview system , so just use it to make your life bit easy. Read more: preview system . Selecting of places Changing of the place See also: placeable object .","title":"place"},{"location":"main-concepts/place/#place","text":"The Place is a description of an environment of the cell . Useful to filter cells which fit to place some part or to process some other way. To create a place , select some folder in the Project window -> Right Mouse Click -> Create -> Domik -> Place .","title":"Place"},{"location":"main-concepts/place/#parts","text":"This is a section to describe an environment of the cell . Floor - a floor where you want to edit environment cells . Top - edit cells on the floor above. Current - edit cells on the same floor as the cell to checking. Down - edit cells on the floor below. Grid - the grid of environment cells . Click on some to start working with this cell . Enable checkbox - set it true if you this cell is a part of the place that you want to find. Parts list - a list of parts that you expect to see in this cell . The Place works better with the Preview system , every change that you make can be rendered by the Preview system , so just use it to make your life bit easy. Read more: preview system . Selecting of places Changing of the place See also: placeable object .","title":"Parts"},{"location":"main-concepts/placeable-object/","text":"Placeable Object \u00b6 The Placeable Object is a container for the part with placing requirements. How to create a Placeable Object? To create a new placeable object , select some folder in the Project window -> Right Mouse Click -> Create -> Domik -> Placeable Object Preview section \u00b6 The Preview section helps you to work with the preview system . This system will draw a result of changes of selected Placeable Object . Turn - select a turn of preview. Build button - press it to rebuild preview manually. Find button - press it to find the Preview system instance in the scene. Settings section \u00b6 The settings section defines that you want to place and where you want to place. Part - the part that you want to place. Changing of the part Possible Places - this is a list of places where this part can be. You can use place s or mask s here. Changing of list of possible places Select of the place Multiple places Actions after placing \u00b6 This section is designed to help you to change an environment of the part after placing. Floor - a floor what you want to change: Top - cells on the floor above of the part . Current - cells of the same floor as the part . Down - cells on the floor below of the part . Here you can see a cells grid. Click on some cell to start working with it. In the panel below, you can see two lists: remove list - parts what you want to remove from this cell . add list - parts what you want to add to this cell . Added and removed parts will be showed on the preview with transparent green and red materials.","title":"placeable object"},{"location":"main-concepts/placeable-object/#placeable-object","text":"The Placeable Object is a container for the part with placing requirements. How to create a Placeable Object? To create a new placeable object , select some folder in the Project window -> Right Mouse Click -> Create -> Domik -> Placeable Object","title":"Placeable Object"},{"location":"main-concepts/placeable-object/#preview-section","text":"The Preview section helps you to work with the preview system . This system will draw a result of changes of selected Placeable Object . Turn - select a turn of preview. Build button - press it to rebuild preview manually. Find button - press it to find the Preview system instance in the scene.","title":"Preview section"},{"location":"main-concepts/placeable-object/#settings-section","text":"The settings section defines that you want to place and where you want to place. Part - the part that you want to place. Changing of the part Possible Places - this is a list of places where this part can be. You can use place s or mask s here. Changing of list of possible places Select of the place Multiple places","title":"Settings section"},{"location":"main-concepts/placeable-object/#actions-after-placing","text":"This section is designed to help you to change an environment of the part after placing. Floor - a floor what you want to change: Top - cells on the floor above of the part . Current - cells of the same floor as the part . Down - cells on the floor below of the part . Here you can see a cells grid. Click on some cell to start working with it. In the panel below, you can see two lists: remove list - parts what you want to remove from this cell . add list - parts what you want to add to this cell . Added and removed parts will be showed on the preview with transparent green and red materials.","title":"Actions after placing"},{"location":"main-concepts/placeable-objects-container/","text":"Placeable Objects Container \u00b6 The Placeable Objects Container is a container of placeable object s or other placeable objects container s. It's designed to group up objects which can present some common idea. Use it with objects which can or should be represented by different parts . Mode - a placing mode: Place All - try to place all items. Use it to group up objects by some topic to make an interior list of placeable objects a bit cleaner. Place First Relevant - iterate over items and stop after the first success of placing. Use it if these items represent an object that trying to adapt to different environments. Example: kitchen stoves for different sizes of the room. Place Random Relevant - place only one item by random. Use it if these items are just variants of one object. Example: a picture on the wall. Placeable Objects list - a list of items that you want to try to place. You can even make a container and fill it with other containers, and it'll try to place all child containers.","title":"placeable objects container"},{"location":"main-concepts/placeable-objects-container/#placeable-objects-container","text":"The Placeable Objects Container is a container of placeable object s or other placeable objects container s. It's designed to group up objects which can present some common idea. Use it with objects which can or should be represented by different parts . Mode - a placing mode: Place All - try to place all items. Use it to group up objects by some topic to make an interior list of placeable objects a bit cleaner. Place First Relevant - iterate over items and stop after the first success of placing. Use it if these items represent an object that trying to adapt to different environments. Example: kitchen stoves for different sizes of the room. Place Random Relevant - place only one item by random. Use it if these items are just variants of one object. Example: a picture on the wall. Placeable Objects list - a list of items that you want to try to place. You can even make a container and fill it with other containers, and it'll try to place all child containers.","title":"Placeable Objects Container"},{"location":"main-concepts/preview-system/","text":"Preview System \u00b6 The Preview System draws configuration files right in the scene. It's pretty useful tool to work with them because you can see changes of files visually in real time. A done Preview System is a prefab in the Domik folder. Drag-and-drop it in the scene to start working with it. The Preview System works with: Part Mask Place Placeable Object Part Preview \u00b6 The Part Preview allows you to see a visual representation of the part . Place Preview \u00b6 The Place Preview allows you to see a visual representation of the place . You can see changes of some Place instantly. Mask Preview \u00b6 The Mask Preview allows you to see a visual representation of the mask . You can see changes of some Mask instantly. Placeable Object Preview \u00b6 The Placeable Object Preview allows you to see a visual representation of the placeable object . You can see changes of some Placeable Object instantly. Changing of the part Changing of the place Select of places Changing of actions after placing See also: how to create a preview system .","title":"preview system"},{"location":"main-concepts/preview-system/#preview-system","text":"The Preview System draws configuration files right in the scene. It's pretty useful tool to work with them because you can see changes of files visually in real time. A done Preview System is a prefab in the Domik folder. Drag-and-drop it in the scene to start working with it. The Preview System works with: Part Mask Place Placeable Object","title":"Preview System"},{"location":"main-concepts/preview-system/#part-preview","text":"The Part Preview allows you to see a visual representation of the part .","title":"Part Preview"},{"location":"main-concepts/preview-system/#place-preview","text":"The Place Preview allows you to see a visual representation of the place . You can see changes of some Place instantly.","title":"Place Preview"},{"location":"main-concepts/preview-system/#mask-preview","text":"The Mask Preview allows you to see a visual representation of the mask . You can see changes of some Mask instantly.","title":"Mask Preview"},{"location":"main-concepts/preview-system/#placeable-object-preview","text":"The Placeable Object Preview allows you to see a visual representation of the placeable object . You can see changes of some Placeable Object instantly. Changing of the part Changing of the place Select of places Changing of actions after placing See also: how to create a preview system .","title":"Placeable Object Preview"},{"location":"main-concepts/skin/","text":"Skin \u00b6 The Skin is a bridge between part s and theirs in-game representations. From the Domik perspective, the house is a structured collection of parts , so it has to convert these parts into real game objects . And the Skin helps the Domik to understand how parts should look like. The Skin is a prefab with a Skin component and a bunch of child game objects with Part Builder components. It also contains a list of bindings between parts and part builders . Settings \u00b6 Cell Width - width and length sizes of the cell. Just write a floor mesh width here (in meters). Cell Height - height of the cell. Just write a wall mesh height here (in meters). Binding \u00b6 Binding list is a list of binding between part and part builders . Create Parts for unbound? - set it true if you want to create new parts for unbound part builders in the process of binding update. Path field - where you want to create new parts? Change Folder button - click to change a folder for new parts . Update Binding button - click it to update a list of bindings. Binds list - a list of binding between parts and part builders . Binds list element \u00b6 Part Builder field - a part builder for the part . Part Builder - a part that you want to build by this part builder . Number field - a rotation offset after building. See also: how to add new stuff , part , part builder , house generator .","title":"skin"},{"location":"main-concepts/skin/#skin","text":"The Skin is a bridge between part s and theirs in-game representations. From the Domik perspective, the house is a structured collection of parts , so it has to convert these parts into real game objects . And the Skin helps the Domik to understand how parts should look like. The Skin is a prefab with a Skin component and a bunch of child game objects with Part Builder components. It also contains a list of bindings between parts and part builders .","title":"Skin"},{"location":"main-concepts/skin/#settings","text":"Cell Width - width and length sizes of the cell. Just write a floor mesh width here (in meters). Cell Height - height of the cell. Just write a wall mesh height here (in meters).","title":"Settings"},{"location":"main-concepts/skin/#binding","text":"Binding list is a list of binding between part and part builders . Create Parts for unbound? - set it true if you want to create new parts for unbound part builders in the process of binding update. Path field - where you want to create new parts? Change Folder button - click to change a folder for new parts . Update Binding button - click it to update a list of bindings. Binds list - a list of binding between parts and part builders .","title":"Binding"},{"location":"main-concepts/skin/#binds-list-element","text":"Part Builder field - a part builder for the part . Part Builder - a part that you want to build by this part builder . Number field - a rotation offset after building. See also: how to add new stuff , part , part builder , house generator .","title":"Binds list element"},{"location":"pipeline-nodes/add-part/","text":"Add Part Node \u00b6 The Add Part node adds a selected part to all input cells. Varieties \u00b6 Add Part 2 Node \u00b6 This node uses in situations where you want to reduce the number of Add Part nodes. Basically this node is equivalent to a chain of two Add Part nodes. Add Part 3 Node \u00b6 An equivalent to a chain of three Add Part nodes. Add Part 4 Node \u00b6 An equivalent to a chain of four Add Part nodes. Add Part To Part Node \u00b6 The Add Part to Part node uses in situations where you want to filter all input cells with specific part and add some part to them. - Target - part what you want to use as a filter - Part - part what you want to add to filtered cells - Mode - Part adding mode: - No Rotation - just add a part to filtered cells - Rotate Only Target - include all possible rotations of the target part to the filter - Rotate Target And Part - filter all possible rotations of the target and add relevant rotation offset to the part.","title":"add part"},{"location":"pipeline-nodes/add-part/#add-part-node","text":"The Add Part node adds a selected part to all input cells.","title":"Add Part Node"},{"location":"pipeline-nodes/add-part/#varieties","text":"","title":"Varieties"},{"location":"pipeline-nodes/add-part/#add-part-2-node","text":"This node uses in situations where you want to reduce the number of Add Part nodes. Basically this node is equivalent to a chain of two Add Part nodes.","title":"Add Part 2 Node"},{"location":"pipeline-nodes/add-part/#add-part-3-node","text":"An equivalent to a chain of three Add Part nodes.","title":"Add Part 3 Node"},{"location":"pipeline-nodes/add-part/#add-part-4-node","text":"An equivalent to a chain of four Add Part nodes.","title":"Add Part 4 Node"},{"location":"pipeline-nodes/add-part/#add-part-to-part-node","text":"The Add Part to Part node uses in situations where you want to filter all input cells with specific part and add some part to them. - Target - part what you want to use as a filter - Part - part what you want to add to filtered cells - Mode - Part adding mode: - No Rotation - just add a part to filtered cells - Rotate Only Target - include all possible rotations of the target part to the filter - Rotate Target And Part - filter all possible rotations of the target and add relevant rotation offset to the part.","title":"Add Part To Part Node"},{"location":"pipeline-nodes/apply-parts-removing/","text":"Apply Parts Removing \u00b6 This node applies parts removing requests. Inputs: In - cells to clean up Remove - parts removing requests which you want to apply Outputs: Out - result Examples \u00b6 A wonderful example of using is showed in the remove part later article.","title":"apply parts removing"},{"location":"pipeline-nodes/apply-parts-removing/#apply-parts-removing","text":"This node applies parts removing requests. Inputs: In - cells to clean up Remove - parts removing requests which you want to apply Outputs: Out - result","title":"Apply Parts Removing"},{"location":"pipeline-nodes/apply-parts-removing/#examples","text":"A wonderful example of using is showed in the remove part later article.","title":"Examples"},{"location":"pipeline-nodes/calculate-room-interiors/","text":"Calculate Room Interiors \u00b6 This node calculates suitable interiors for rooms. You have to return calculated interiors to the END node as it shows below. Inputs: In - cells to analyze Outputs: Room Interiors - suitable interiors for rooms Explain \u00b6 There is no effect of room's calculating if you don't return it to the END node. But what will happen if you return the result of calculations to the END node But... There is furniture? To add furniture you have to use a Place Furniture node. Wait, wait, are these the same interiors? Why did the walls change color? That's because walls materials defined by the skins system, and in this example skins are dynamic. Every room has a bunch of randomly selected skins, and if you used a random engine somewhere before using of the skins, the result of the skins selecting will be different. So yes, these are the same interiors, but with another skins. You can also return calculated room interiors by the Return Interiors node as it shows below.","title":"calculate room interiors"},{"location":"pipeline-nodes/calculate-room-interiors/#calculate-room-interiors","text":"This node calculates suitable interiors for rooms. You have to return calculated interiors to the END node as it shows below. Inputs: In - cells to analyze Outputs: Room Interiors - suitable interiors for rooms","title":"Calculate Room Interiors"},{"location":"pipeline-nodes/calculate-room-interiors/#explain","text":"There is no effect of room's calculating if you don't return it to the END node. But what will happen if you return the result of calculations to the END node But... There is furniture? To add furniture you have to use a Place Furniture node. Wait, wait, are these the same interiors? Why did the walls change color? That's because walls materials defined by the skins system, and in this example skins are dynamic. Every room has a bunch of randomly selected skins, and if you used a random engine somewhere before using of the skins, the result of the skins selecting will be different. So yes, these are the same interiors, but with another skins. You can also return calculated room interiors by the Return Interiors node as it shows below.","title":"Explain"},{"location":"pipeline-nodes/create-skins-layer/","text":"Create Skins Layer \u00b6 This node creates an override skins layer, use it if you want to add some special look for several cells. Inputs: In - cells for which you want to override the look Outputs: Skins Layer - a result data that you have to return to the end node to apply changes Properties: Skin - skin that you want to apply to input cells. Examples \u00b6 In this example we'll change a color of basement floor facade walls. Now let's filter a basement floor. Now we can use filtered cells as a base for the Skins Layer. Apply changes by the Return Skins Layer node.","title":"create skins layer"},{"location":"pipeline-nodes/create-skins-layer/#create-skins-layer","text":"This node creates an override skins layer, use it if you want to add some special look for several cells. Inputs: In - cells for which you want to override the look Outputs: Skins Layer - a result data that you have to return to the end node to apply changes Properties: Skin - skin that you want to apply to input cells.","title":"Create Skins Layer"},{"location":"pipeline-nodes/create-skins-layer/#examples","text":"In this example we'll change a color of basement floor facade walls. Now let's filter a basement floor. Now we can use filtered cells as a base for the Skins Layer. Apply changes by the Return Skins Layer node.","title":"Examples"},{"location":"pipeline-nodes/end/","text":"End \u00b6 An End node is a final node of the pipeline. You should have one to work with the Pipeline properly. Inputs: Cells - cells to be built Override Skin Layers - cells which should have special skin instead of own.","title":"end"},{"location":"pipeline-nodes/end/#end","text":"An End node is a final node of the pipeline. You should have one to work with the Pipeline properly. Inputs: Cells - cells to be built Override Skin Layers - cells which should have special skin instead of own.","title":"End"},{"location":"pipeline-nodes/exclude/","text":"Exclude \u00b6 This node excludes cells B from cells A. Inputs: A - cells which you want to process B - cells which you want to exclude from A Outputs: Out - result Examples \u00b6 Input is a house that has been completed. Now let's filter facade. Now we can exclude it from the main cells flow.","title":"exclude"},{"location":"pipeline-nodes/exclude/#exclude","text":"This node excludes cells B from cells A. Inputs: A - cells which you want to process B - cells which you want to exclude from A Outputs: Out - result","title":"Exclude"},{"location":"pipeline-nodes/exclude/#examples","text":"Input is a house that has been completed. Now let's filter facade. Now we can exclude it from the main cells flow.","title":"Examples"},{"location":"pipeline-nodes/extract-positions/","text":"Extract Positions \u00b6 This node extract positions of input cells to use them later. Pretty useful to save positions of some processed cells. Inputs: Cells - cells to extract Outputs: Positions - extracted positions Examples \u00b6 A good example of using this node is showed here: filter by positions","title":"extract positions"},{"location":"pipeline-nodes/extract-positions/#extract-positions","text":"This node extract positions of input cells to use them later. Pretty useful to save positions of some processed cells. Inputs: Cells - cells to extract Outputs: Positions - extracted positions","title":"Extract Positions"},{"location":"pipeline-nodes/extract-positions/#examples","text":"A good example of using this node is showed here: filter by positions","title":"Examples"},{"location":"pipeline-nodes/filter-by-floor-tag/","text":"Filter By Floor Tag \u00b6 This node filter cells by the floor tag . Use this node to filter and process a specific floor. Inputs: In - cells to filter Outputs: Success - filtered cells Failed - unfiltered cells Properties: Floor Tag - a floor tag that will be used as a filter Examples \u00b6 Input is a house that has been completed. Now lets filter a floor with a Roof floor tag. Success output Failed output","title":"filter by floor tag"},{"location":"pipeline-nodes/filter-by-floor-tag/#filter-by-floor-tag","text":"This node filter cells by the floor tag . Use this node to filter and process a specific floor. Inputs: In - cells to filter Outputs: Success - filtered cells Failed - unfiltered cells Properties: Floor Tag - a floor tag that will be used as a filter","title":"Filter By Floor Tag"},{"location":"pipeline-nodes/filter-by-floor-tag/#examples","text":"Input is a house that has been completed. Now lets filter a floor with a Roof floor tag. Success output Failed output","title":"Examples"},{"location":"pipeline-nodes/filter-by-mask/","text":"Filter By Mask \u00b6 Use this node to filter cells by some mask. Inputs: In - cells to filter Outputs: 0 - cells filtered by mask 90 - cells filtered by mask that has been rotated by 90 degrees 180 - cells filtered by mask that has been rotated by 180 degrees 270 - cells filtered by mask that has been rotated by 270 degrees Properties: - Mask - a mask to use as a filter. Examples \u00b6 Input is a house that has been completed. Now lets use a Forward House Borders mask as a filter. Nodes Mask Result Other outputs Mask rotated by 90 degrees Mask rotated by 180 degrees Mask rotated by 270 degrees Merged rotations Merged and inverted","title":"filter by mask"},{"location":"pipeline-nodes/filter-by-mask/#filter-by-mask","text":"Use this node to filter cells by some mask. Inputs: In - cells to filter Outputs: 0 - cells filtered by mask 90 - cells filtered by mask that has been rotated by 90 degrees 180 - cells filtered by mask that has been rotated by 180 degrees 270 - cells filtered by mask that has been rotated by 270 degrees Properties: - Mask - a mask to use as a filter.","title":"Filter By Mask"},{"location":"pipeline-nodes/filter-by-mask/#examples","text":"Input is a house that has been completed. Now lets use a Forward House Borders mask as a filter. Nodes Mask Result Other outputs Mask rotated by 90 degrees Mask rotated by 180 degrees Mask rotated by 270 degrees Merged rotations Merged and inverted","title":"Examples"},{"location":"pipeline-nodes/filter-by-positions/","text":"Filter By Positions \u00b6 This node filters cells by positions. Inputs: In - cells to filter Positions - Positions of cells which should be filtered Outputs: Out - filtered cells Examples \u00b6 Input is a house that has been completed. Now lets extract positions of random cells and use them as a filter.","title":"filter by positions"},{"location":"pipeline-nodes/filter-by-positions/#filter-by-positions","text":"This node filters cells by positions. Inputs: In - cells to filter Positions - Positions of cells which should be filtered Outputs: Out - filtered cells","title":"Filter By Positions"},{"location":"pipeline-nodes/filter-by-positions/#examples","text":"Input is a house that has been completed. Now lets extract positions of random cells and use them as a filter.","title":"Examples"},{"location":"pipeline-nodes/filter-floor/","text":"Filter Floor \u00b6 Use this node to filter concrete floor. Inputs: In - cells to filter Floor - input number (optional). Outputs: Out - filtered cells Properties: Number - Number of the floor to filter Examples \u00b6 Input is a house that has been completed. Now lets filter the first floor","title":"filter floor"},{"location":"pipeline-nodes/filter-floor/#filter-floor","text":"Use this node to filter concrete floor. Inputs: In - cells to filter Floor - input number (optional). Outputs: Out - filtered cells Properties: Number - Number of the floor to filter","title":"Filter Floor"},{"location":"pipeline-nodes/filter-floor/#examples","text":"Input is a house that has been completed. Now lets filter the first floor","title":"Examples"},{"location":"pipeline-nodes/filter-internal-doors-places/","text":"Filter Internal Doors Places \u00b6 This node filters best places for doors between rooms. You have to add parts for all outputs and then merge them together in most situations. Inputs: In - cells to filter Outputs: 0 - cells for door part with original rotation 90 - cells for door part rotated by 90 degrees 180 - cells for door part rotated by 180 degrees 270 - cells for door part rotated by 270 degrees Examples \u00b6 Input is a set of barebone rooms without extarnal walls, windows, furniture etc. Now let's filter best places for doors and look up to the result. Looks... strange and useless. But it's not actually. Let's add a [0] Internal Doorway part to add a more context. Much Better! But now we have a parts overlapping. To solve it we have to remove [0] internal wall parts from filtered cells. Wonderful! Now let's repeat it for other rotations and merge them. Don't use a Remove Part node before the merge node! Don't use a Remove Part node before the merge node! It'll cause artifacts because there is no way to merge removing actions properly. Instead of that use the Remove Part Later and the Apply Parts Removing as it shows below. Still looks like a mess, but we have all doors! Last step - applying changes to the main cells flow.","title":"filter internal doors places"},{"location":"pipeline-nodes/filter-internal-doors-places/#filter-internal-doors-places","text":"This node filters best places for doors between rooms. You have to add parts for all outputs and then merge them together in most situations. Inputs: In - cells to filter Outputs: 0 - cells for door part with original rotation 90 - cells for door part rotated by 90 degrees 180 - cells for door part rotated by 180 degrees 270 - cells for door part rotated by 270 degrees","title":"Filter Internal Doors Places"},{"location":"pipeline-nodes/filter-internal-doors-places/#examples","text":"Input is a set of barebone rooms without extarnal walls, windows, furniture etc. Now let's filter best places for doors and look up to the result. Looks... strange and useless. But it's not actually. Let's add a [0] Internal Doorway part to add a more context. Much Better! But now we have a parts overlapping. To solve it we have to remove [0] internal wall parts from filtered cells. Wonderful! Now let's repeat it for other rotations and merge them. Don't use a Remove Part node before the merge node! Don't use a Remove Part node before the merge node! It'll cause artifacts because there is no way to merge removing actions properly. Instead of that use the Remove Part Later and the Apply Parts Removing as it shows below. Still looks like a mess, but we have all doors! Last step - applying changes to the main cells flow.","title":"Examples"},{"location":"pipeline-nodes/filter-intersections/","text":"Filter Intersections \u00b6 This node filters intersected cells between A and B inputs. Inputs: A - first pool of cells to check intersection B - second pool of cells to check intersection Outputs: Out - result Examples \u00b6 Input is a house that has been completed. Now let's filter these cells by Forward House Borders mask. Now look at the result of mask rotation by 90 degrees. Perfect candidate for finding of cells intersection. Let's find an intersection between cells filtered by 0\u00b0 and by 90\u00b0 rotations of the mask! You can even invert the result by the Exclude node.","title":"filter intersections"},{"location":"pipeline-nodes/filter-intersections/#filter-intersections","text":"This node filters intersected cells between A and B inputs. Inputs: A - first pool of cells to check intersection B - second pool of cells to check intersection Outputs: Out - result","title":"Filter Intersections"},{"location":"pipeline-nodes/filter-intersections/#examples","text":"Input is a house that has been completed. Now let's filter these cells by Forward House Borders mask. Now look at the result of mask rotation by 90 degrees. Perfect candidate for finding of cells intersection. Let's find an intersection between cells filtered by 0\u00b0 and by 90\u00b0 rotations of the mask! You can even invert the result by the Exclude node.","title":"Examples"},{"location":"pipeline-nodes/filter-neighbor-cells/","text":"Filter Neighbor \u00b6 This node filters target neighbor cells. Inputs: All - the main cells flow Target - cells for which you want to find neighbors Outputs: Top - top neighbor cells Bottom - bottom neighbor cells Forward - forward neighbor cells Backward - backward neighbor cells Right - right neighbor cells Left - left neighbor cells Examples \u00b6 Input is a house that has been completed. Let's filter the right side of the house. Now we can slice this house like a pie by using the Filter Neighbor Cells node. Or we can make something mad... Another example: let's select some random cell: Now we can add some cells around: This node is pretty useful for situations when you want to filter some floor. Let's filter the Basement floor by the Filter by Tag node. Now we can filter the top floor by the Filter Neighbor Cells node. Well, now, we can, for example, change the facade look.","title":"filter neighbor cells"},{"location":"pipeline-nodes/filter-neighbor-cells/#filter-neighbor","text":"This node filters target neighbor cells. Inputs: All - the main cells flow Target - cells for which you want to find neighbors Outputs: Top - top neighbor cells Bottom - bottom neighbor cells Forward - forward neighbor cells Backward - backward neighbor cells Right - right neighbor cells Left - left neighbor cells","title":"Filter Neighbor"},{"location":"pipeline-nodes/filter-neighbor-cells/#examples","text":"Input is a house that has been completed. Let's filter the right side of the house. Now we can slice this house like a pie by using the Filter Neighbor Cells node. Or we can make something mad... Another example: let's select some random cell: Now we can add some cells around: This node is pretty useful for situations when you want to filter some floor. Let's filter the Basement floor by the Filter by Tag node. Now we can filter the top floor by the Filter Neighbor Cells node. Well, now, we can, for example, change the facade look.","title":"Examples"},{"location":"pipeline-nodes/filter-random-cells/","text":"Filter Random Cells \u00b6 Use this node to filter random cells Inputs: In - cells to filter Outputs: Success - filtered cells Failed - \u0441ells that have not been filtered Properties: Count - how many cells you want to filter Examples \u00b6 Input is a house that has been completed. Now lets add a Filter Random Cells node. Result: Failed output:","title":"filter random cells"},{"location":"pipeline-nodes/filter-random-cells/#filter-random-cells","text":"Use this node to filter random cells Inputs: In - cells to filter Outputs: Success - filtered cells Failed - \u0441ells that have not been filtered Properties: Count - how many cells you want to filter","title":"Filter Random Cells"},{"location":"pipeline-nodes/filter-random-cells/#examples","text":"Input is a house that has been completed. Now lets add a Filter Random Cells node. Result: Failed output:","title":"Examples"},{"location":"pipeline-nodes/filter-random-input/","text":"Filter Random Input \u00b6 This node filters random input cells flow. Inputs: In - cell inputs to select random flow. Outputs: Out - result Properties: Mode: Single - return only one cells flow Multiple - merge and return several cell flows Examples \u00b6 Input is a house that has been completed. Now let's filter a house border Now we can select a random Filter By Mask node output by the Filter Random Input node. And this is a result of the filtering with a Multiple mode on.","title":"filter random input"},{"location":"pipeline-nodes/filter-random-input/#filter-random-input","text":"This node filters random input cells flow. Inputs: In - cell inputs to select random flow. Outputs: Out - result Properties: Mode: Single - return only one cells flow Multiple - merge and return several cell flows","title":"Filter Random Input"},{"location":"pipeline-nodes/filter-random-input/#examples","text":"Input is a house that has been completed. Now let's filter a house border Now we can select a random Filter By Mask node output by the Filter Random Input node. And this is a result of the filtering with a Multiple mode on.","title":"Examples"},{"location":"pipeline-nodes/filter-with-part/","text":"Filter With Part \u00b6 This node allows you to filter cells which contains some part. Inputs: In - cells to filter Outputs: Success - cells with a target Part Failed - cells without a target Part Properties: Part - part what will be used as a filter Examples \u00b6 Input is a house that has been completed. Now we can filter all cells with an Audio System without a rotation offset. To filter all rotations use a Filter With Part 4 node with a Filter with Any mode as it shows below","title":"filter with part"},{"location":"pipeline-nodes/filter-with-part/#filter-with-part","text":"This node allows you to filter cells which contains some part. Inputs: In - cells to filter Outputs: Success - cells with a target Part Failed - cells without a target Part Properties: Part - part what will be used as a filter","title":"Filter With Part"},{"location":"pipeline-nodes/filter-with-part/#examples","text":"Input is a house that has been completed. Now we can filter all cells with an Audio System without a rotation offset. To filter all rotations use a Filter With Part 4 node with a Filter with Any mode as it shows below","title":"Examples"},{"location":"pipeline-nodes/filter-with-parts/","text":"Filter With Parts \u00b6 This node filters cells with several parts. Inputs: In - cells to filter Outputs: Success - filtered cells Properties: Part Fields - targets to filter Filter With: Any - filter cells, which contain any target part. All - filter cells, which contains all target parts. Examples \u00b6 Input is a house that has been completed. Filter With Any Mode \u00b6 This mode is pretty useful for situations when you want to find all variations of some part. In this example we will filter cells with a Bed Segment part with all possible rotations. Filter With All Mode \u00b6 This mode is good when you want to find cells which should looks special. Here we will filter a room corners.","title":"filter with parts"},{"location":"pipeline-nodes/filter-with-parts/#filter-with-parts","text":"This node filters cells with several parts. Inputs: In - cells to filter Outputs: Success - filtered cells Properties: Part Fields - targets to filter Filter With: Any - filter cells, which contain any target part. All - filter cells, which contains all target parts.","title":"Filter With Parts"},{"location":"pipeline-nodes/filter-with-parts/#examples","text":"Input is a house that has been completed.","title":"Examples"},{"location":"pipeline-nodes/filter-with-parts/#filter-with-any-mode","text":"This mode is pretty useful for situations when you want to find all variations of some part. In this example we will filter cells with a Bed Segment part with all possible rotations.","title":"Filter With Any Mode"},{"location":"pipeline-nodes/filter-with-parts/#filter-with-all-mode","text":"This mode is good when you want to find cells which should looks special. Here we will filter a room corners.","title":"Filter With All Mode"},{"location":"pipeline-nodes/filter-without-part/","text":"Filter Without Part \u00b6 This node allows you to filter cells without some part. Inputs: In - cells to filter Outputs: Out - cells without a target Part Properties: Part - part what you want to use as exclude filter Examples \u00b6 Input is a house that has been completed. Now let's exclude cells with a yellow facade.","title":"filter without part"},{"location":"pipeline-nodes/filter-without-part/#filter-without-part","text":"This node allows you to filter cells without some part. Inputs: In - cells to filter Outputs: Out - cells without a target Part Properties: Part - part what you want to use as exclude filter","title":"Filter Without Part"},{"location":"pipeline-nodes/filter-without-part/#examples","text":"Input is a house that has been completed. Now let's exclude cells with a yellow facade.","title":"Examples"},{"location":"pipeline-nodes/find-and-replace/","text":"Find And Replace \u00b6 This node allows you to replace some part with other part. It'll try to process replacing for all rotations of target cells if it's possible. Inputs: In - cells to process replacing Outputs: Out - result of replacing Properties: Target - part to replace New Part - part to use as replace Examples \u00b6 For this example we'll change a facade of complete house. Now we'll replace a thin window walls with a regular window walls by the Find And Replace node.","title":"find and replace"},{"location":"pipeline-nodes/find-and-replace/#find-and-replace","text":"This node allows you to replace some part with other part. It'll try to process replacing for all rotations of target cells if it's possible. Inputs: In - cells to process replacing Outputs: Out - result of replacing Properties: Target - part to replace New Part - part to use as replace","title":"Find And Replace"},{"location":"pipeline-nodes/find-and-replace/#examples","text":"For this example we'll change a facade of complete house. Now we'll replace a thin window walls with a regular window walls by the Find And Replace node.","title":"Examples"},{"location":"pipeline-nodes/merge/","text":"Merge \u00b6 This node merges input cells together. Inputs: In - cells to merge. Multiple input is accessible (obviously) Outputs: Out - merge result Don't use a Remove Part node before the merge node! Don't use a Remove Part node before the merge node! It'll cause artifacts because there is no way to merge removing actions properly. Instead of that use the Remove Part Later and the Apply Parts Removing as it shows below. Wrong: Good: Examples \u00b6 Input is a house that has been completed. Let's filter house corners by the Forward Right House Corners mask. That's how result looks if we were select a 90 degree output. Now we can merge all mask rotations together to get all corners of the house.","title":"merge"},{"location":"pipeline-nodes/merge/#merge","text":"This node merges input cells together. Inputs: In - cells to merge. Multiple input is accessible (obviously) Outputs: Out - merge result Don't use a Remove Part node before the merge node! Don't use a Remove Part node before the merge node! It'll cause artifacts because there is no way to merge removing actions properly. Instead of that use the Remove Part Later and the Apply Parts Removing as it shows below. Wrong: Good:","title":"Merge"},{"location":"pipeline-nodes/merge/#examples","text":"Input is a house that has been completed. Let's filter house corners by the Forward Right House Corners mask. That's how result looks if we were select a 90 degree output. Now we can merge all mask rotations together to get all corners of the house.","title":"Examples"},{"location":"pipeline-nodes/override-skins-layer/","text":"Override Skins Layer \u00b6 This node allows you to combine two Skins Layer flows together. Inputs: A - a skins layer flow that will be overriden. B - a skins layer flow that will override an A flow. Outputs: Result - a result of overriding A flow by the B flow. Examples \u00b6 In this example we'll repaint facades of completed house. Now we'll create two skins layer flows and combine them together by overriding","title":"override skins layer"},{"location":"pipeline-nodes/override-skins-layer/#override-skins-layer","text":"This node allows you to combine two Skins Layer flows together. Inputs: A - a skins layer flow that will be overriden. B - a skins layer flow that will override an A flow. Outputs: Result - a result of overriding A flow by the B flow.","title":"Override Skins Layer"},{"location":"pipeline-nodes/override-skins-layer/#examples","text":"In this example we'll repaint facades of completed house. Now we'll create two skins layer flows and combine them together by overriding","title":"Examples"},{"location":"pipeline-nodes/override/","text":"Override \u00b6 This node overrides cells A with cells B . Overriding process will replace A cells with B cells with the same position. Most often used in situations where you have filtered cells to a separate flow, changed them, and now want to apply the changes to the main flow. Inputs: A - cells flow which you want to override B - cells that will override Outputs: Out - overriding result Examples \u00b6 Input is a house that has been completed. Let's remove windows from yellow walls by the Find and Replace node. Now we can apply changes to the main flow by the Override node. Interesting Case \u00b6 In this example we will see an interesting point of cells overriding. To do this, we must shift the top floor up. Let's filter roof cells by the Flat Roof Places node. Now let's shift it up by the Shift node. Now let's apply changes by the overriding node. Very strange result! It looks like, instead of moving, we just copied and pasted the top floor. The override node works pretty similar to the Merge Node but with one exception - instead of merging overlapped cells it just replace it with new. In this example, there is no overlapped cells, so top floor cells just added to the house as a bunch of new cells. How to solve it? Just exclude a filtered floor!","title":"override"},{"location":"pipeline-nodes/override/#override","text":"This node overrides cells A with cells B . Overriding process will replace A cells with B cells with the same position. Most often used in situations where you have filtered cells to a separate flow, changed them, and now want to apply the changes to the main flow. Inputs: A - cells flow which you want to override B - cells that will override Outputs: Out - overriding result","title":"Override"},{"location":"pipeline-nodes/override/#examples","text":"Input is a house that has been completed. Let's remove windows from yellow walls by the Find and Replace node. Now we can apply changes to the main flow by the Override node.","title":"Examples"},{"location":"pipeline-nodes/override/#interesting-case","text":"In this example we will see an interesting point of cells overriding. To do this, we must shift the top floor up. Let's filter roof cells by the Flat Roof Places node. Now let's shift it up by the Shift node. Now let's apply changes by the overriding node. Very strange result! It looks like, instead of moving, we just copied and pasted the top floor. The override node works pretty similar to the Merge Node but with one exception - instead of merging overlapped cells it just replace it with new. In this example, there is no overlapped cells, so top floor cells just added to the house as a bunch of new cells. How to solve it? Just exclude a filtered floor!","title":"Interesting Case"},{"location":"pipeline-nodes/place-furniture/","text":"Place Furniture \u00b6 This node places interior furniture to input cells. Inputs: In - cells to place furniture Room Interiors - An info about rooms of interiors. To calculate it use a Calculate Room Interiors node. Outputs: Out - result Read this to find out how to... Add look for furniture - how to add new stuff . Create new furniture - how to create and use a placeable object . Add furniture to the interior - interior Examples \u00b6 In this example we will use precalculated cells with empty rooms Now let's calculate Rooms Interiors to know what interior should be for every room. And now we can add furniture","title":"place furniture"},{"location":"pipeline-nodes/place-furniture/#place-furniture","text":"This node places interior furniture to input cells. Inputs: In - cells to place furniture Room Interiors - An info about rooms of interiors. To calculate it use a Calculate Room Interiors node. Outputs: Out - result Read this to find out how to... Add look for furniture - how to add new stuff . Create new furniture - how to create and use a placeable object . Add furniture to the interior - interior","title":"Place Furniture"},{"location":"pipeline-nodes/place-furniture/#examples","text":"In this example we will use precalculated cells with empty rooms Now let's calculate Rooms Interiors to know what interior should be for every room. And now we can add furniture","title":"Examples"},{"location":"pipeline-nodes/place-part-by-mask-for-all-rotations/","text":"Place Part By Mask For All Rotations \u00b6 This node allows you to find places by the mask and place a Part there. It'll process placing for all four rotations, so it's pretty useful if you want to place something somewhere and you don't care about specific rotations. And yeah, it'll place this part for every found suitable place. Inputs: In - cells there you want to place a part Outputs: Out - placing result Properties: Part - Part that you want to place Mask - Mask that represents a place there you want to place a Part . Examples \u00b6 For this example we will generate a house basic cells, split it by rooms, add floor parts and calculate interiors. Now let's add some walls here! To do it we'll use a Place Part By Mask For All Rotations node with a Forward Rooms Borders mask. This is an alternative way to do the same thing:","title":"place part by mask for all rotations"},{"location":"pipeline-nodes/place-part-by-mask-for-all-rotations/#place-part-by-mask-for-all-rotations","text":"This node allows you to find places by the mask and place a Part there. It'll process placing for all four rotations, so it's pretty useful if you want to place something somewhere and you don't care about specific rotations. And yeah, it'll place this part for every found suitable place. Inputs: In - cells there you want to place a part Outputs: Out - placing result Properties: Part - Part that you want to place Mask - Mask that represents a place there you want to place a Part .","title":"Place Part By Mask For All Rotations"},{"location":"pipeline-nodes/place-part-by-mask-for-all-rotations/#examples","text":"For this example we will generate a house basic cells, split it by rooms, add floor parts and calculate interiors. Now let's add some walls here! To do it we'll use a Place Part By Mask For All Rotations node with a Forward Rooms Borders mask. This is an alternative way to do the same thing:","title":"Examples"},{"location":"pipeline-nodes/place-placeable-object-forced/","text":"Place Placeable Object Forced \u00b6 This node is an alternative to Add Part Node , but, unlike it, it applies changes to the surrounding space. Inputs: All - the main cells flow Target - cells in that you want to place a placeable object Outputs: Out - placing result Properties: Placeable Object - a placeable object that you want to place Turn - force turning Examples \u00b6 For this example we'll use a very simple house blank. Let's imagine that we want to place some stairs in a specific cell. That will happens if you'll use an Add Part node? Well... something like that. Looks totally wrong, that's because we are not removed internal walls, ceiling and floor on the top floor. We can remove them by the Remove Part node, or... we can just apply Placeable Object actions! To do it we have to use a Place Placeable Object Forced . We already have a preconfigurated Stairs Placeable Object, so let's use it. And we can even rotate it if we want.","title":"place placeable object forced"},{"location":"pipeline-nodes/place-placeable-object-forced/#place-placeable-object-forced","text":"This node is an alternative to Add Part Node , but, unlike it, it applies changes to the surrounding space. Inputs: All - the main cells flow Target - cells in that you want to place a placeable object Outputs: Out - placing result Properties: Placeable Object - a placeable object that you want to place Turn - force turning","title":"Place Placeable Object Forced"},{"location":"pipeline-nodes/place-placeable-object-forced/#examples","text":"For this example we'll use a very simple house blank. Let's imagine that we want to place some stairs in a specific cell. That will happens if you'll use an Add Part node? Well... something like that. Looks totally wrong, that's because we are not removed internal walls, ceiling and floor on the top floor. We can remove them by the Remove Part node, or... we can just apply Placeable Object actions! To do it we have to use a Place Placeable Object Forced . We already have a preconfigurated Stairs Placeable Object, so let's use it. And we can even rotate it if we want.","title":"Examples"},{"location":"pipeline-nodes/place-placeable-object/","text":"Place Placeable Object \u00b6 This node places a PlaceableObject or PlaceableObjectsContainer to input cells. Inputs: In - cells to place. Outputs: Out - placing result. Properties: Placing Mode: Once Per House - try to place this Placeable Object only once somewhere into the house. Once Per Floor - try to place this Placeable Object once per floor. Once Per Room - try to place this Placeable Object in every room. In Every Cell - try to place this Placeable Object in every input cell. A Placeable - placeable object or placeable objects container what you want to place. Examples \u00b6 For this examples we'll use generated rooms without anything as it shows below. Now let's add a Chilling Small Section placeable object with different placing rules. Once Per Cell With this parameter node will try to place a PlaceableObject on every cell. Once Per Room With this parameter node will try to place a PlaceableObject only once per room. Once Per Floor With this parameter node will try to place a PlaceableObject only once per floor. The result of selecting this parameter pretty hard to show, because there is only one chilling section per floor now. Once Per House With this parameter node will try to place a PlaceableObject only once per house. Now it's even harder because there is only one place where this Placeable Object can be. There is no necessary to use a main cells flow as an input, you can filter some bunch of cells and place some PlaceableObject there, just don't forget to override a main cells flow after that. Let's filter several random cells. Now let's place things on them. And now we can apply it to the main cells flow.","title":"place placeable object"},{"location":"pipeline-nodes/place-placeable-object/#place-placeable-object","text":"This node places a PlaceableObject or PlaceableObjectsContainer to input cells. Inputs: In - cells to place. Outputs: Out - placing result. Properties: Placing Mode: Once Per House - try to place this Placeable Object only once somewhere into the house. Once Per Floor - try to place this Placeable Object once per floor. Once Per Room - try to place this Placeable Object in every room. In Every Cell - try to place this Placeable Object in every input cell. A Placeable - placeable object or placeable objects container what you want to place.","title":"Place Placeable Object"},{"location":"pipeline-nodes/place-placeable-object/#examples","text":"For this examples we'll use generated rooms without anything as it shows below. Now let's add a Chilling Small Section placeable object with different placing rules. Once Per Cell With this parameter node will try to place a PlaceableObject on every cell. Once Per Room With this parameter node will try to place a PlaceableObject only once per room. Once Per Floor With this parameter node will try to place a PlaceableObject only once per floor. The result of selecting this parameter pretty hard to show, because there is only one chilling section per floor now. Once Per House With this parameter node will try to place a PlaceableObject only once per house. Now it's even harder because there is only one place where this Placeable Object can be. There is no necessary to use a main cells flow as an input, you can filter some bunch of cells and place some PlaceableObject there, just don't forget to override a main cells flow after that. Let's filter several random cells. Now let's place things on them. And now we can apply it to the main cells flow.","title":"Examples"},{"location":"pipeline-nodes/place-stairs/","text":"Place Stairs \u00b6 This node provides a placing of stairs. Inputs: All - the main cells flow Target - cells where you want to place stairs Forbidden - cells that are forbidden to change Outputs: Out - floor cells that are now connected by stairs Failed - floor cells that have not been connected Properties: Stairs - a placeable object of stairs Min Stairwell Length - a minimal length of the stairwell, low number makes this stairs less realistic but more universal. Examples \u00b6 For this example we'll use a house without interiors, furniture and facades, because the Place Stairs Node designed to be used before calculating and applying interiors. Now we'll try to place a Stairs 6x6 by the Place Stairs node. Here we'll use the same cells flow for the All input and for the Target input because we want to try to place a Stairs 6x5 in whole house. Here windows and doors intersect with the stairs and this is not fine. To solve it we have to add cells with them to the Forbidden input. Top First Person Now this is fine. But sometimes the house structure too complicated to be able to use only one stairs, so you have to add more stairs to connect other floors. In the next example we'll generate a house with another SEED. Last 2 floors are not connected no, so we have to fix it. If you want to see not connected floors use a Failed output. To fix it let's try to place less demanding stairs. All cells that were processed by the placing of stairs now has a Busy part, so we can (and should) ignore them by adding them to forbidden cells. We also use a failed output as a target input because we want to place this stairs in not connected floors. A staircase appeared on the back of the house, between the last two floors. Now all floors are connected.","title":"place stairs"},{"location":"pipeline-nodes/place-stairs/#place-stairs","text":"This node provides a placing of stairs. Inputs: All - the main cells flow Target - cells where you want to place stairs Forbidden - cells that are forbidden to change Outputs: Out - floor cells that are now connected by stairs Failed - floor cells that have not been connected Properties: Stairs - a placeable object of stairs Min Stairwell Length - a minimal length of the stairwell, low number makes this stairs less realistic but more universal.","title":"Place Stairs"},{"location":"pipeline-nodes/place-stairs/#examples","text":"For this example we'll use a house without interiors, furniture and facades, because the Place Stairs Node designed to be used before calculating and applying interiors. Now we'll try to place a Stairs 6x6 by the Place Stairs node. Here we'll use the same cells flow for the All input and for the Target input because we want to try to place a Stairs 6x5 in whole house. Here windows and doors intersect with the stairs and this is not fine. To solve it we have to add cells with them to the Forbidden input. Top First Person Now this is fine. But sometimes the house structure too complicated to be able to use only one stairs, so you have to add more stairs to connect other floors. In the next example we'll generate a house with another SEED. Last 2 floors are not connected no, so we have to fix it. If you want to see not connected floors use a Failed output. To fix it let's try to place less demanding stairs. All cells that were processed by the placing of stairs now has a Busy part, so we can (and should) ignore them by adding them to forbidden cells. We also use a failed output as a target input because we want to place this stairs in not connected floors. A staircase appeared on the back of the house, between the last two floors. Now all floors are connected.","title":"Examples"},{"location":"pipeline-nodes/remove-part-later/","text":"Remove Part Later \u00b6 This node collects an information about cells which you want to clear from some part in the future. Inputs: In - cells to clear Outputs: Out - result Properties: Part - part that you want to remove from cells Examples \u00b6 For this example we'll use a simple blanket of the house. Now let's try to place windows. It seems that nothing happened, but if you look at the house from the other side, it becomes clear that internal walls are blocking windows. So let's fix it! The naive way to fix it is just using a Remove Part node. Looks almost good, but there are walls in the corner, although they shouldn't be there. Why? Well... we have the corner cell in the both flows at the same time, so, in process of merging we have two intersected cells with the same position, but one still has left internal wall, and second has right internal wall, so they both add these walls to the final cell when merging. Merging results of removing will always cause artifacts in intersected cells, so don't merge results of removing. But... that to do? Answer is simple. Just remove parts AFTER merging! And exactly for that there are the Remove Parts Later node and the Apply Removing node.","title":"remove part later"},{"location":"pipeline-nodes/remove-part-later/#remove-part-later","text":"This node collects an information about cells which you want to clear from some part in the future. Inputs: In - cells to clear Outputs: Out - result Properties: Part - part that you want to remove from cells","title":"Remove Part Later"},{"location":"pipeline-nodes/remove-part-later/#examples","text":"For this example we'll use a simple blanket of the house. Now let's try to place windows. It seems that nothing happened, but if you look at the house from the other side, it becomes clear that internal walls are blocking windows. So let's fix it! The naive way to fix it is just using a Remove Part node. Looks almost good, but there are walls in the corner, although they shouldn't be there. Why? Well... we have the corner cell in the both flows at the same time, so, in process of merging we have two intersected cells with the same position, but one still has left internal wall, and second has right internal wall, so they both add these walls to the final cell when merging. Merging results of removing will always cause artifacts in intersected cells, so don't merge results of removing. But... that to do? Answer is simple. Just remove parts AFTER merging! And exactly for that there are the Remove Parts Later node and the Apply Removing node.","title":"Examples"},{"location":"pipeline-nodes/remove-part/","text":"Remove Part \u00b6 This node removes a part from cells. Inputs: In - cells in that you want to remove a part Outputs: Out - removing result Properties: Part field - part that you want to remove from cells Examples \u00b6 For this example we'll use a simple blank of the house. In this example we'll select random cells on the last floor and remove some walls from them. Now let's filter the last floor. Next filter random cells. And remove a wall from them. And the final step - applying changes on the main cells flow by the Overriding node. !Note Don't use a Remove Part node before the Merge node! It'll cause artifacts because there is no way to merge removing actions properly. Instead of that use the Remove Part Later and the Apply Parts Removing as it shows below. Wrong: Good:","title":"remove part"},{"location":"pipeline-nodes/remove-part/#remove-part","text":"This node removes a part from cells. Inputs: In - cells in that you want to remove a part Outputs: Out - removing result Properties: Part field - part that you want to remove from cells","title":"Remove Part"},{"location":"pipeline-nodes/remove-part/#examples","text":"For this example we'll use a simple blank of the house. In this example we'll select random cells on the last floor and remove some walls from them. Now let's filter the last floor. Next filter random cells. And remove a wall from them. And the final step - applying changes on the main cells flow by the Overriding node. !Note Don't use a Remove Part node before the Merge node! It'll cause artifacts because there is no way to merge removing actions properly. Instead of that use the Remove Part Later and the Apply Parts Removing as it shows below. Wrong: Good:","title":"Examples"},{"location":"pipeline-nodes/return-interiors/","text":"Return Interiors \u00b6 This node provides an alternative way to apply calculated rooms interiors. Use it if you want to make your pipeline structure cleaner. Inputs: Room Interiors - Room Interiors which you want to return to the End node Examples \u00b6 These two methods give the same result. Return by the End node Return by the Return Room Interiors node","title":"return interiors"},{"location":"pipeline-nodes/return-interiors/#return-interiors","text":"This node provides an alternative way to apply calculated rooms interiors. Use it if you want to make your pipeline structure cleaner. Inputs: Room Interiors - Room Interiors which you want to return to the End node","title":"Return Interiors"},{"location":"pipeline-nodes/return-interiors/#examples","text":"These two methods give the same result. Return by the End node Return by the Return Room Interiors node","title":"Examples"},{"location":"pipeline-nodes/return-skins-layer/","text":"Return Skins Layer \u00b6 This node provides an alternative way to apply a skins layer. Use it if you want to make your pipeline structure cleaner. Inputs: Skins Layer - a skins layer that you want to return to the End node. Examples \u00b6 These two methods give the same result. Return by the End node Return by the Return Skins Layer node","title":"return skins layer"},{"location":"pipeline-nodes/return-skins-layer/#return-skins-layer","text":"This node provides an alternative way to apply a skins layer. Use it if you want to make your pipeline structure cleaner. Inputs: Skins Layer - a skins layer that you want to return to the End node.","title":"Return Skins Layer"},{"location":"pipeline-nodes/return-skins-layer/#examples","text":"These two methods give the same result. Return by the End node Return by the Return Skins Layer node","title":"Examples"},{"location":"pipeline-nodes/shift/","text":"Shift \u00b6 This node shifts input cells Inputs: In - cells to shift Outputs: Out - result of shifting Properties: X - X axis offset Y - Y axis offset Floor - floor offset Examples \u00b6 In this example we'll shift a right side of the house. At first we have to filter a right side of the house. Now we can shift it. Let'd apply changes by the Override node. A very strange result, isn't it? That's because the process of overriding works with positions, not with cell id, so, from the perspective of the overriding node, we created some bunch of cells somewhere outside of the house and now trying to add them to the house. So, it just doing it. To solve this problem we have to just exclude cells which we want to shift.","title":"shift"},{"location":"pipeline-nodes/shift/#shift","text":"This node shifts input cells Inputs: In - cells to shift Outputs: Out - result of shifting Properties: X - X axis offset Y - Y axis offset Floor - floor offset","title":"Shift"},{"location":"pipeline-nodes/shift/#examples","text":"In this example we'll shift a right side of the house. At first we have to filter a right side of the house. Now we can shift it. Let'd apply changes by the Override node. A very strange result, isn't it? That's because the process of overriding works with positions, not with cell id, so, from the perspective of the overriding node, we created some bunch of cells somewhere outside of the house and now trying to add them to the house. So, it just doing it. To solve this problem we have to just exclude cells which we want to shift.","title":"Examples"},{"location":"pipeline-nodes/shuffle/","text":"Shuffle \u00b6 This node shuffles an order of cells in the flow. Pretty useful if you want to add more random. Inputs: In - cells to shuffle Outputs: Out - result Examples \u00b6 Input is a house that has been completed. Let's filter random cells. If we want to filter another 30 cells, we can shuffle input cells by the Shuffle node.","title":"shuffle"},{"location":"pipeline-nodes/shuffle/#shuffle","text":"This node shuffles an order of cells in the flow. Pretty useful if you want to add more random. Inputs: In - cells to shuffle Outputs: Out - result","title":"Shuffle"},{"location":"pipeline-nodes/shuffle/#examples","text":"Input is a house that has been completed. Let's filter random cells. If we want to filter another 30 cells, we can shuffle input cells by the Shuffle node.","title":"Examples"},{"location":"pipeline-nodes/split-into-rooms/","text":"Split Into Rooms \u00b6 This node splits input cells to rooms. Every cell has its own RoomId, by default it's zero. Splitting By Rooms node splits cells by setting new RoomId to them, so, after this process, you can work with borders of cells by filtering them with a Mask. Inputs: In - cells to split Outputs: Out - result of splitting. Properties: Min Size - minimum side length of rooms Max Size - maximum side length of rooms Examples \u00b6 In this example we'll split floors into rooms, find relative interiors to them and place furniture. First we have to add floor and ceiling to all cells. Now let's try to split it into rooms And... Nothing happened! That's because the Split Into Rooms node just sets a RoomID to all cells, to actually split this house into rooms we should add walls in borders of rooms. Let's do it. Yay! It works! But that will happen if we'll try to do it without splitting into rooms? Well... One big room, as expected. Now let's add doors, interiors and furniture! !Note: It's better to add doors and windows before interiors and furniture because interiors calculating and furniture placing are sensitive for doors and windows. Next we have to calculate and apply interiors. Finish: add furniture.","title":"split into rooms"},{"location":"pipeline-nodes/split-into-rooms/#split-into-rooms","text":"This node splits input cells to rooms. Every cell has its own RoomId, by default it's zero. Splitting By Rooms node splits cells by setting new RoomId to them, so, after this process, you can work with borders of cells by filtering them with a Mask. Inputs: In - cells to split Outputs: Out - result of splitting. Properties: Min Size - minimum side length of rooms Max Size - maximum side length of rooms","title":"Split Into Rooms"},{"location":"pipeline-nodes/split-into-rooms/#examples","text":"In this example we'll split floors into rooms, find relative interiors to them and place furniture. First we have to add floor and ceiling to all cells. Now let's try to split it into rooms And... Nothing happened! That's because the Split Into Rooms node just sets a RoomID to all cells, to actually split this house into rooms we should add walls in borders of rooms. Let's do it. Yay! It works! But that will happen if we'll try to do it without splitting into rooms? Well... One big room, as expected. Now let's add doors, interiors and furniture! !Note: It's better to add doors and windows before interiors and furniture because interiors calculating and furniture placing are sensitive for doors and windows. Next we have to calculate and apply interiors. Finish: add furniture.","title":"Examples"},{"location":"pipeline-nodes/start/","text":"Start \u00b6 This is an enter point to the generation process. Data from the House Generator component uses to create a bunch of start cells, so, if you want to add more floors to the generation process, you have to add them to the House Generator component and so on. Outputs: Cells - cells constructed from a data from the House Generator component. Examples \u00b6 In this example we created a base cells with a size data from the House Generator component and added a Venus part to them.","title":"start"},{"location":"pipeline-nodes/start/#start","text":"This is an enter point to the generation process. Data from the House Generator component uses to create a bunch of start cells, so, if you want to add more floors to the generation process, you have to add them to the House Generator component and so on. Outputs: Cells - cells constructed from a data from the House Generator component.","title":"Start"},{"location":"pipeline-nodes/start/#examples","text":"In this example we created a base cells with a size data from the House Generator component and added a Venus part to them.","title":"Examples"},{"location":"tutorials/deep-dive-into-house-building-process/","text":"Deep dive into house building process \u00b6 The process of house generation works in three steps: Generating of house cells Extracting a house build data from cells Building a house from an extracted house build data 1. Generating house cells . \u00b6 This step provides by the Pipeline - a visual scripting system. From the Pipeline perspective there is no 3D meshes, materials, textures etc. The Pipeline works with an abstract idea of parts of the house. And the name of this abstract thing is... The Part ! Pretty obvious :D That is the Part? \u00b6 The part is a scriptable object with name and references to 3 other parts with rotations by 90 , 180 and 270 degrees. Some parts have no rotations (example: floor, ceiling, round table...) so rotated parts references will be empty and that's fine. Part without rotations The most important aspect of the part is its name . The part's name is all that the Pipeline should know to start working with it. You can even have two parts with different GUID but with the same name and the Pipeline will think that they are equals. The Pipeline has only one target - create cells. That are Cells? \u00b6 Cells is an abstract representation of house in the code. To understand the conception, just image a house as a 3D grid of cells. (\u256e\u00b0-\u00b0)\u256e\u2533\u2501\u2501\u2533 ( \u256f\u00b0\u25a1\u00b0)\u256f \u253b\u2501\u2501\u253b Each cell contains a floor, ceiling, walls and something else. Floor, ceiling and walls are parts . So yeah, cells is just a 3D grid of parts lists. Representation in code Cells Cell In the pipeline you create cells, modify them, remove, merge and so on. And in the end you return the result in the end node. Created cells comes to the second step of the generation - extracting a house build data from cells. 2. Extracting a house build data from cells . \u00b6 The Build Data Extractor transforms cells from an abstract representation of house to the house building instruction. It sorts cells to floors and rooms and finds part's builder for all cell's parts . Part Builders are stored in skins , so the Build Data Extractor asks them if they have something to build some part . If there is no Part Builder for some part , this part will be ignored during house building. The priority of skins asking from highest to lowest: Skins Layer Interior Skins House Skins Skins Layer Interior Skins House Skins You can change a look of the room by changing interior skins because they have higher priority than house skins . The Skins Layer has been created for special cases when you want to change a look of some cells filtered by special rules in the Pipeline . So in the result it returns a structured collection of Part Builders - a House Build Data . Representation in code Floors Floor Room Cell 3. Building of the house by the house build data. \u00b6 The House Builder takes a house build data and just build it! It's more complicated, actually, but there is no reason to dive so deep. But why so complicated? \u00b6 Well, there is only one reason - flexibility. If you are a programmer, you may know the conception of model-view splitting. The Part is a model and the Part Builder is a view. Part is an abstract idea of something, and the Part Builder builds a look of it. Thanks to this separation, we can redefine how a cell should look right on the fly. For example, you created some pipeline which generates a simple village house. And you have a regular village where you want to place it. But then you want to add a village which was corrupted by chaos, with lakes of blood, rusted chains and so on. But you have this innocent, vibrant, happy house! That's not that you want. Thanks to this separation, you just need to edit skins to change a view of house. You don't need to touch the Pipeline at all. And that's wonderful.","title":"deep dive into house building process"},{"location":"tutorials/deep-dive-into-house-building-process/#deep-dive-into-house-building-process","text":"The process of house generation works in three steps: Generating of house cells Extracting a house build data from cells Building a house from an extracted house build data","title":"Deep dive into house building process"},{"location":"tutorials/deep-dive-into-house-building-process/#1-generating-house-cells","text":"This step provides by the Pipeline - a visual scripting system. From the Pipeline perspective there is no 3D meshes, materials, textures etc. The Pipeline works with an abstract idea of parts of the house. And the name of this abstract thing is... The Part ! Pretty obvious :D","title":"1. Generating house cells."},{"location":"tutorials/deep-dive-into-house-building-process/#that-is-the-part","text":"The part is a scriptable object with name and references to 3 other parts with rotations by 90 , 180 and 270 degrees. Some parts have no rotations (example: floor, ceiling, round table...) so rotated parts references will be empty and that's fine. Part without rotations The most important aspect of the part is its name . The part's name is all that the Pipeline should know to start working with it. You can even have two parts with different GUID but with the same name and the Pipeline will think that they are equals. The Pipeline has only one target - create cells.","title":"That is the Part?"},{"location":"tutorials/deep-dive-into-house-building-process/#that-are-cells","text":"Cells is an abstract representation of house in the code. To understand the conception, just image a house as a 3D grid of cells. (\u256e\u00b0-\u00b0)\u256e\u2533\u2501\u2501\u2533 ( \u256f\u00b0\u25a1\u00b0)\u256f \u253b\u2501\u2501\u253b Each cell contains a floor, ceiling, walls and something else. Floor, ceiling and walls are parts . So yeah, cells is just a 3D grid of parts lists. Representation in code Cells Cell In the pipeline you create cells, modify them, remove, merge and so on. And in the end you return the result in the end node. Created cells comes to the second step of the generation - extracting a house build data from cells.","title":"That are Cells?"},{"location":"tutorials/deep-dive-into-house-building-process/#2-extracting-a-house-build-data-from-cells","text":"The Build Data Extractor transforms cells from an abstract representation of house to the house building instruction. It sorts cells to floors and rooms and finds part's builder for all cell's parts . Part Builders are stored in skins , so the Build Data Extractor asks them if they have something to build some part . If there is no Part Builder for some part , this part will be ignored during house building. The priority of skins asking from highest to lowest: Skins Layer Interior Skins House Skins Skins Layer Interior Skins House Skins You can change a look of the room by changing interior skins because they have higher priority than house skins . The Skins Layer has been created for special cases when you want to change a look of some cells filtered by special rules in the Pipeline . So in the result it returns a structured collection of Part Builders - a House Build Data . Representation in code Floors Floor Room Cell","title":"2. Extracting a house build data from cells."},{"location":"tutorials/deep-dive-into-house-building-process/#3-building-of-the-house-by-the-house-build-data","text":"The House Builder takes a house build data and just build it! It's more complicated, actually, but there is no reason to dive so deep.","title":"3. Building of the house by the house build data."},{"location":"tutorials/deep-dive-into-house-building-process/#but-why-so-complicated","text":"Well, there is only one reason - flexibility. If you are a programmer, you may know the conception of model-view splitting. The Part is a model and the Part Builder is a view. Part is an abstract idea of something, and the Part Builder builds a look of it. Thanks to this separation, we can redefine how a cell should look right on the fly. For example, you created some pipeline which generates a simple village house. And you have a regular village where you want to place it. But then you want to add a village which was corrupted by chaos, with lakes of blood, rusted chains and so on. But you have this innocent, vibrant, happy house! That's not that you want. Thanks to this separation, you just need to edit skins to change a view of house. You don't need to touch the Pipeline at all. And that's wonderful.","title":"But why so complicated?"},{"location":"tutorials/facades-workflow/","text":"Facades workflow \u00b6 The look of facades is controlling by two systems: Skin system Floor Tag system Here is the next idea: you define a look of the house facade by skins, and then you select suitable skins for each floor in the Pipeline by floor tags. Facade of the house that we use in these examples is separated to five skins - thin facade, regular facade, thick facade, columns and plinth Change facades by floor tags \u00b6 This method provides by the pipeline . To use it, just select some floor and change its floor tag . It works because an example pipeline includes special logic. Here, cells of floors with facade tags will be filtered and processed to achieve the final result. You can create other tags and generation steps to make things different. Read more: floor tag Change facades by house skins \u00b6 Select the House Generator on the scene and look at the House Skins panel. Here is already added a random container for facade palettes. We have to add new skin in top of this skins list to override the house facade. A facade of the house is separated into five skins, but in this tutorial we will change only one - Facade Regular skin . To do it we have to duplicate this skin and edit it. We can just change this skin as it shows in the how to change room walls article too. Go to the Domik folder -> House Example -> Skins -> Facade Walls Regular , duplicate some skin and open it. Now replace materials with something other. Exit with saving, drag-n-drop this skin in top of the House Generator skins list and regenerate the house to check out the result. You can also change meshes of walls or add something new. Let's make this wall even worse to add new window frames.","title":"facades workflow"},{"location":"tutorials/facades-workflow/#facades-workflow","text":"The look of facades is controlling by two systems: Skin system Floor Tag system Here is the next idea: you define a look of the house facade by skins, and then you select suitable skins for each floor in the Pipeline by floor tags. Facade of the house that we use in these examples is separated to five skins - thin facade, regular facade, thick facade, columns and plinth","title":"Facades workflow"},{"location":"tutorials/facades-workflow/#change-facades-by-floor-tags","text":"This method provides by the pipeline . To use it, just select some floor and change its floor tag . It works because an example pipeline includes special logic. Here, cells of floors with facade tags will be filtered and processed to achieve the final result. You can create other tags and generation steps to make things different. Read more: floor tag","title":"Change facades by floor tags"},{"location":"tutorials/facades-workflow/#change-facades-by-house-skins","text":"Select the House Generator on the scene and look at the House Skins panel. Here is already added a random container for facade palettes. We have to add new skin in top of this skins list to override the house facade. A facade of the house is separated into five skins, but in this tutorial we will change only one - Facade Regular skin . To do it we have to duplicate this skin and edit it. We can just change this skin as it shows in the how to change room walls article too. Go to the Domik folder -> House Example -> Skins -> Facade Walls Regular , duplicate some skin and open it. Now replace materials with something other. Exit with saving, drag-n-drop this skin in top of the House Generator skins list and regenerate the house to check out the result. You can also change meshes of walls or add something new. Let's make this wall even worse to add new window frames.","title":"Change facades by house skins"},{"location":"tutorials/how-the-domik-builds-a-house/","text":"How the Domik builds a house \u00b6 (\u256e\u00b0-\u00b0)\u256e\u2533\u2501\u2501\u2533 ( \u256f\u00b0\u25a1\u00b0)\u256f \u253b\u2501\u2501\u253b House is a builded cells. Cells are a grid collection of parts with positions. Parts are just names of objects that you want to see there. So, to build a house, the House Builder should find visual representations for these parts and place them in relevant positions. A visual representation of the part is a game object with a Part Builder component. From now on, we will simply refer to them as Part Builder. Part Skin Binding of a part Part Builder Result of building So, to build a Part, the house builder should find a Part Builder to it. How does it do it? The house builder will try to find it in skins. Skin is a collection of Part Builders. Skins are stored in interiors and in the House Generator skins list. Interior House Generator Interior skins have higher priority than house skins , so the House Builder will try to find it in them at first. If the house builder find a Part Builder, it'll just ask it to build this part. What does it mean for us? If we want to change something, we have to find and change its visual representation (a Part Builder) in skins. If it's a part of the room, in most situations it can be found in some interior skin, if it's a part of the facade or something common, it can be in the House Generator skins list. So how do you figure out which interior is applied to a room? You can do it visually or you can look at the name of the room, this name is the same as the name of the applied interior. Rooms Interiors How the room gets an interior? Interior of the room is set in the process of the Calculate Room Interiors node, basically this node just sets some interior from the Floor interiors list. See also: how to change room walls , how to replace models or materials .","title":"how the domik builds a house"},{"location":"tutorials/how-the-domik-builds-a-house/#how-the-domik-builds-a-house","text":"(\u256e\u00b0-\u00b0)\u256e\u2533\u2501\u2501\u2533 ( \u256f\u00b0\u25a1\u00b0)\u256f \u253b\u2501\u2501\u253b House is a builded cells. Cells are a grid collection of parts with positions. Parts are just names of objects that you want to see there. So, to build a house, the House Builder should find visual representations for these parts and place them in relevant positions. A visual representation of the part is a game object with a Part Builder component. From now on, we will simply refer to them as Part Builder. Part Skin Binding of a part Part Builder Result of building So, to build a Part, the house builder should find a Part Builder to it. How does it do it? The house builder will try to find it in skins. Skin is a collection of Part Builders. Skins are stored in interiors and in the House Generator skins list. Interior House Generator Interior skins have higher priority than house skins , so the House Builder will try to find it in them at first. If the house builder find a Part Builder, it'll just ask it to build this part. What does it mean for us? If we want to change something, we have to find and change its visual representation (a Part Builder) in skins. If it's a part of the room, in most situations it can be found in some interior skin, if it's a part of the facade or something common, it can be in the House Generator skins list. So how do you figure out which interior is applied to a room? You can do it visually or you can look at the name of the room, this name is the same as the name of the applied interior. Rooms Interiors How the room gets an interior? Interior of the room is set in the process of the Calculate Room Interiors node, basically this node just sets some interior from the Floor interiors list. See also: how to change room walls , how to replace models or materials .","title":"How the Domik builds a house"},{"location":"tutorials/how-to-add-new-stuff/","text":"How to add new stuff \u00b6 From the Domik perspective there is no difference between walls, doors, furniture or something else. It's all parts . If you want to add new furniture, you have to create a new part and a visual representation of it by the part builder and the skin . That's how it works: You click the Generate button in the House Generator . The House Generator requests its Pipeline to generate house cells (each cell is a container of parts ). The Pipeline returns house cells to the House Builder . The House Builder iterates over cells and asks skins if they have some view ( PartBuilder ) for this part of the cell and if it is, the House Builder build it. Read more: how the domik builds a house , deep dive into house building process . Let's try to add a new chair to see how it works. There are two workflows which you can use to add new parts of the house: Manual - do it by your hands. Automated - trust automation. Manual \u00b6 Manual workflow is a slow and ineffective method of adding new house parts, but it's simple and intuitive . It's not recommended in most situations . First, we have to create a chair part . To do, it click on some folder -> Create -> Domik -> Part But that's not enough. The chair can have at least four rotations, so we have to add three more parts. Now let's look at the Chair Part 's inspector. Here we have references to other rotated parts. We have to set them to make things works properly. Repeat it for Chair Right , Chair Left and Chair Backward parts. Result of setting up of parts. Chair Chair Right Chair Left Chair Backward Now we need to create part builder s for these parts , to do it we have to use the skin system. We can extend an existed skin or create a brand new. Let's extend some furniture skin. To do it go to the Domik folder -> House Example -> Skins -> Furniture -> open Furniture Origin Basically, a Skin is a prefab with the Skin component , so you can use it as a regular prefab. In this example we'll open a Furniture Origin prefab because it's a root prefab. Furniture Black , Furniture White and Furniture Wooden Light are nested prefabs, so if you'll add something in the Furniture Origin prefabs it automatically will be added to these nested prefabs. Adding Part's builder to the furniture skin \u00b6 That's how the regular skin looks like. In the hierarchy window, you can see tons of objects. They're represents of look of parts. That's fine to disable objects to hide them. Disabled objects with Part Builder components will work as usual, but if you'll disable their child object, this change will affect the result of the house building. The Skin component is in the root object, select it to work with it. Now let's make a Part Builder for our chair! Drag and drop some model prefab to the skin's hierarchy to do it. Now we have to add a Part Builder component to it. After that, we have to bind this Part Builder with a Part in the Binds list in the Skin component. The number in the end is the rotation offset. Set it zero. There is no need to use it in this tutorial. Repeat it with the rest of the turns and add rotations. Congrats! Let's check out the result. If the Preview System draws parts , you did everything right. Now you can use it to create a Placeable Object ! Read next: how to create and use a placeable object , placeable object . Automated \u00b6 Another way to add new stuff is using an auto-binding. This workflow is recommended. Add that you want into the skin, name it with an [auto] prefix and click an Auto Binding button. The Skin will scan all parts in the project and if It'll find the part and the Part Builder with the same name (except prefix in square brackets) - it'll bind them together. What'll happen if there is no part for the Part Builder ? There are two variants, depends on the Create Parts for unbound? checkbox: On - parts for this Part Builder will be created in the selected folder and binded with it. Off - this Part Builder will be ignored. There are five possible prefixes: [auto] - create or find four parts with [0] , [90] , [180] , and [270] degrees rotations. [0] - create or find a part with a [0] degrees rotation. [90] - create or find a part with a [90] degrees rotation. [180] - create or find a part with a [180] degrees rotation. [270] - create or find a part with a [270] degrees rotation. Let's see it in action! Open the Furniture Origin skin and drag-n-drop the chair prefab to it's hierarchy. Add the Part Builder component to it. Add an [auto] prefix to it's name. Use name prefixes only with things which can be rotated. It'll work only if you use an auto-binding function. Go to the Skin component and enable a Create Parts for unbound? checkbox if it disabled. Now the Skin will create parts for Part Builders which doesn't have relevant parts in the project. Select a folder there you want to put new parts. Now all new parts will be created in this folder. Click an Update Binding button. We use only one Part Builder for all rotations, so there are rotation offsets to add a rotation in the process of building. The rotation offset is a number in the end of the binding field. Done! Let's check it. There is a problem: the chair rotates with little shift. That's because the chair is not in the centre of the cell. Let's fix it! To do it, move the chair to the centre of the cell. Checking out. Congratulations! Now you can use these parts to create a Placeable Object . See also: how to create and use a placeable object , placeable object .","title":"how to add new stuff"},{"location":"tutorials/how-to-add-new-stuff/#how-to-add-new-stuff","text":"From the Domik perspective there is no difference between walls, doors, furniture or something else. It's all parts . If you want to add new furniture, you have to create a new part and a visual representation of it by the part builder and the skin . That's how it works: You click the Generate button in the House Generator . The House Generator requests its Pipeline to generate house cells (each cell is a container of parts ). The Pipeline returns house cells to the House Builder . The House Builder iterates over cells and asks skins if they have some view ( PartBuilder ) for this part of the cell and if it is, the House Builder build it. Read more: how the domik builds a house , deep dive into house building process . Let's try to add a new chair to see how it works. There are two workflows which you can use to add new parts of the house: Manual - do it by your hands. Automated - trust automation.","title":"How to add new stuff"},{"location":"tutorials/how-to-add-new-stuff/#manual","text":"Manual workflow is a slow and ineffective method of adding new house parts, but it's simple and intuitive . It's not recommended in most situations . First, we have to create a chair part . To do, it click on some folder -> Create -> Domik -> Part But that's not enough. The chair can have at least four rotations, so we have to add three more parts. Now let's look at the Chair Part 's inspector. Here we have references to other rotated parts. We have to set them to make things works properly. Repeat it for Chair Right , Chair Left and Chair Backward parts. Result of setting up of parts. Chair Chair Right Chair Left Chair Backward Now we need to create part builder s for these parts , to do it we have to use the skin system. We can extend an existed skin or create a brand new. Let's extend some furniture skin. To do it go to the Domik folder -> House Example -> Skins -> Furniture -> open Furniture Origin Basically, a Skin is a prefab with the Skin component , so you can use it as a regular prefab. In this example we'll open a Furniture Origin prefab because it's a root prefab. Furniture Black , Furniture White and Furniture Wooden Light are nested prefabs, so if you'll add something in the Furniture Origin prefabs it automatically will be added to these nested prefabs.","title":"Manual"},{"location":"tutorials/how-to-add-new-stuff/#adding-parts-builder-to-the-furniture-skin","text":"That's how the regular skin looks like. In the hierarchy window, you can see tons of objects. They're represents of look of parts. That's fine to disable objects to hide them. Disabled objects with Part Builder components will work as usual, but if you'll disable their child object, this change will affect the result of the house building. The Skin component is in the root object, select it to work with it. Now let's make a Part Builder for our chair! Drag and drop some model prefab to the skin's hierarchy to do it. Now we have to add a Part Builder component to it. After that, we have to bind this Part Builder with a Part in the Binds list in the Skin component. The number in the end is the rotation offset. Set it zero. There is no need to use it in this tutorial. Repeat it with the rest of the turns and add rotations. Congrats! Let's check out the result. If the Preview System draws parts , you did everything right. Now you can use it to create a Placeable Object ! Read next: how to create and use a placeable object , placeable object .","title":"Adding Part's builder to the furniture skin"},{"location":"tutorials/how-to-add-new-stuff/#automated","text":"Another way to add new stuff is using an auto-binding. This workflow is recommended. Add that you want into the skin, name it with an [auto] prefix and click an Auto Binding button. The Skin will scan all parts in the project and if It'll find the part and the Part Builder with the same name (except prefix in square brackets) - it'll bind them together. What'll happen if there is no part for the Part Builder ? There are two variants, depends on the Create Parts for unbound? checkbox: On - parts for this Part Builder will be created in the selected folder and binded with it. Off - this Part Builder will be ignored. There are five possible prefixes: [auto] - create or find four parts with [0] , [90] , [180] , and [270] degrees rotations. [0] - create or find a part with a [0] degrees rotation. [90] - create or find a part with a [90] degrees rotation. [180] - create or find a part with a [180] degrees rotation. [270] - create or find a part with a [270] degrees rotation. Let's see it in action! Open the Furniture Origin skin and drag-n-drop the chair prefab to it's hierarchy. Add the Part Builder component to it. Add an [auto] prefix to it's name. Use name prefixes only with things which can be rotated. It'll work only if you use an auto-binding function. Go to the Skin component and enable a Create Parts for unbound? checkbox if it disabled. Now the Skin will create parts for Part Builders which doesn't have relevant parts in the project. Select a folder there you want to put new parts. Now all new parts will be created in this folder. Click an Update Binding button. We use only one Part Builder for all rotations, so there are rotation offsets to add a rotation in the process of building. The rotation offset is a number in the end of the binding field. Done! Let's check it. There is a problem: the chair rotates with little shift. That's because the chair is not in the centre of the cell. Let's fix it! To do it, move the chair to the centre of the cell. Checking out. Congratulations! Now you can use these parts to create a Placeable Object . See also: how to create and use a placeable object , placeable object .","title":"Automated"},{"location":"tutorials/how-to-change-a-house-size/","text":"How to change a house size \u00b6 A size of the house is controlled by the Base Size panel in the House Generator component. This panel defines the target size of the house. The final size can be different and depends on the pipeline logic. Read more: start . Width - target width of the house. Length - target length of the house. Floors - target floors count. You can select between two size modes: const and rand const - constant size. rand - random size. Const size changes Rand size changes","title":"how to change a house size"},{"location":"tutorials/how-to-change-a-house-size/#how-to-change-a-house-size","text":"A size of the house is controlled by the Base Size panel in the House Generator component. This panel defines the target size of the house. The final size can be different and depends on the pipeline logic. Read more: start . Width - target width of the house. Length - target length of the house. Floors - target floors count. You can select between two size modes: const and rand const - constant size. rand - random size. Const size changes Rand size changes","title":"How to change a house size"},{"location":"tutorials/how-to-change-house-floors/","text":"How to change house floors \u00b6 To change house floors, you have to edit a floors list in the Floors panel of the house generator component. This panel contains a list of floor scriptable objects, an order of list elements is inverted, so, if you want to add something like a basement floor, you have to order it to the end of the list. Flex floors are floors that can be duplicated to achieve a target size of the house, so it's better to add them in the middle of the house. Every floor contains an interior list and floor tag s. Read more: floor .","title":"how to change house floors"},{"location":"tutorials/how-to-change-house-floors/#how-to-change-house-floors","text":"To change house floors, you have to edit a floors list in the Floors panel of the house generator component. This panel contains a list of floor scriptable objects, an order of list elements is inverted, so, if you want to add something like a basement floor, you have to order it to the end of the list. Flex floors are floors that can be duplicated to achieve a target size of the house, so it's better to add them in the middle of the house. Every floor contains an interior list and floor tag s. Read more: floor .","title":"How to change house floors"},{"location":"tutorials/how-to-change-room-walls/","text":"How to change room walls \u00b6 In this tutorial we will change the walls of the living room. To do this, we have to work with the \"Living Room\" interior. Here we have a Skins list. This list defines how a room with this interior will look like. What is a Living Room (Palettes Random Container) in the list of skins? This interior contains a Living Room (Palettes Random Container) . The Palettes Random Container uses to select a random palette from lists of palettes. The Palette is a collection of skins which looks good together. So, a room with this interior will use skins of random palette from the Living Room (Palettes Random Container) . Top elements of the skins list will override bottoms, so to change a look of the room, we can just add a new skin in top of this list. Let's duplicate some skin, change it and add in the top of the interior skins list. Go to Domik folder -> House Example -> Skins -> Walls Here are three folders: Now open the Regular folder. These are skins. Skins are basically just prefabs with skin component on the root object and some children objects with part builder components. You can use all features of regular prefabs with them, including nesting of prefabs . Walls Origin here is an original prefab and all other wall prefabs are nested , so if you make some changes of Origin skin prefab it'll make effects on nested . We just need to change walls material so let's just duplicate some nested skin and open it to edit. This skin contains five PartBuilders . Now let's create some material and add it to the wall. Repeat it for other PartBuilders. Quit from prefab edit mode, add the result skin to the Living Room Interior and checkout the result by regenerating of house. Congrats! Now you know how to change walls of the house. Similarly, you can change the rest of the room, including the ceiling, floor and furniture.","title":"how to change room walls"},{"location":"tutorials/how-to-change-room-walls/#how-to-change-room-walls","text":"In this tutorial we will change the walls of the living room. To do this, we have to work with the \"Living Room\" interior. Here we have a Skins list. This list defines how a room with this interior will look like. What is a Living Room (Palettes Random Container) in the list of skins? This interior contains a Living Room (Palettes Random Container) . The Palettes Random Container uses to select a random palette from lists of palettes. The Palette is a collection of skins which looks good together. So, a room with this interior will use skins of random palette from the Living Room (Palettes Random Container) . Top elements of the skins list will override bottoms, so to change a look of the room, we can just add a new skin in top of this list. Let's duplicate some skin, change it and add in the top of the interior skins list. Go to Domik folder -> House Example -> Skins -> Walls Here are three folders: Now open the Regular folder. These are skins. Skins are basically just prefabs with skin component on the root object and some children objects with part builder components. You can use all features of regular prefabs with them, including nesting of prefabs . Walls Origin here is an original prefab and all other wall prefabs are nested , so if you make some changes of Origin skin prefab it'll make effects on nested . We just need to change walls material so let's just duplicate some nested skin and open it to edit. This skin contains five PartBuilders . Now let's create some material and add it to the wall. Repeat it for other PartBuilders. Quit from prefab edit mode, add the result skin to the Living Room Interior and checkout the result by regenerating of house. Congrats! Now you know how to change walls of the house. Similarly, you can change the rest of the room, including the ceiling, floor and furniture.","title":"How to change room walls"},{"location":"tutorials/how-to-create-a-place/","text":"How to work with the Place. \u00b6 The place is a description of some place in the house. Read more place . To create a place right click on some folder -> Create -> Domik -> Place We'll create a room corner with window in this tutorial. We have to select central cell and set part s to recreate a look of the place. Done! Now we can use it in the Placeable Object to define where we want to place it. Final step - add it to an interior of the room there we want to see it. Yep, now it has been placed in the corner with window.","title":"how to create a place"},{"location":"tutorials/how-to-create-a-place/#how-to-work-with-the-place","text":"The place is a description of some place in the house. Read more place . To create a place right click on some folder -> Create -> Domik -> Place We'll create a room corner with window in this tutorial. We have to select central cell and set part s to recreate a look of the place. Done! Now we can use it in the Placeable Object to define where we want to place it. Final step - add it to an interior of the room there we want to see it. Yep, now it has been placed in the corner with window.","title":"How to work with the Place."},{"location":"tutorials/how-to-create-a-preview-system/","text":"How to create a Preview System \u00b6 The Preview system provides a rendering of The Domik configuration files. Read More: preview system . This tutorial will show you how to create an instance of this system, but you can just drag'n'drop a preconfigured prefab into the scene. You have to create an empty GameObject in the scene and add the Preview component to it to create an instance of the Preview system. Add these GameObjects as child: Placeable Object Place Part Mask Add these GameObjects for the Placeable Object as child: Env Add Remove Place or Mask Part Other Add Mesh Filter and Mesh Renderer components to all child except the Other GameObject. Set links of Placeable Object child to the Preview component. Set links to other child to the **Preview **component. Set the base size of the skin . Move objects apart Now we have to add materials. Accessible Inaccessible Place Add Remove Environment Final step - setting up skins . Checkout the result.","title":"how to create a preview system"},{"location":"tutorials/how-to-create-a-preview-system/#how-to-create-a-preview-system","text":"The Preview system provides a rendering of The Domik configuration files. Read More: preview system . This tutorial will show you how to create an instance of this system, but you can just drag'n'drop a preconfigured prefab into the scene. You have to create an empty GameObject in the scene and add the Preview component to it to create an instance of the Preview system. Add these GameObjects as child: Placeable Object Place Part Mask Add these GameObjects for the Placeable Object as child: Env Add Remove Place or Mask Part Other Add Mesh Filter and Mesh Renderer components to all child except the Other GameObject. Set links of Placeable Object child to the Preview component. Set links to other child to the **Preview **component. Set the base size of the skin . Move objects apart Now we have to add materials. Accessible Inaccessible Place Add Remove Environment Final step - setting up skins . Checkout the result.","title":"How to create a Preview System"},{"location":"tutorials/how-to-create-a-procedural-house/","text":"How to create a procedural house \u00b6 There are two ways to create a procedural house. Drag-and-drop a prefab Open the Domik folder Select House Example prefab Drag-n-Drop it on the scene. Select it on the scene Click Generate From Random button in the Inspector. Create as a new gameobject in the scene Create new gameobject in the scene. Add a House Generator component to it. Select a Regular House pipeline in the pipeline property in the House Generator component. Set house sizes in the Base Size menu. Add a Regular Floor skin to the House Skins property. Add a Basement floor, FLEX Regular Floor and a Roof floors with correct order as it shows below. Click the Generate Random button. You can duplicate it if you want. Select House Example Prefab in the Hierarchy . Press Ctrl-D to duplicate prefab instance in the scene. Change the position on duplicated house by dragging gizmo handle. Click Generate Random button to regenerate it. Repeat. Click a Generate Random button again to randomize look of the house.","title":"how to create a procedural house"},{"location":"tutorials/how-to-create-a-procedural-house/#how-to-create-a-procedural-house","text":"There are two ways to create a procedural house. Drag-and-drop a prefab Open the Domik folder Select House Example prefab Drag-n-Drop it on the scene. Select it on the scene Click Generate From Random button in the Inspector. Create as a new gameobject in the scene Create new gameobject in the scene. Add a House Generator component to it. Select a Regular House pipeline in the pipeline property in the House Generator component. Set house sizes in the Base Size menu. Add a Regular Floor skin to the House Skins property. Add a Basement floor, FLEX Regular Floor and a Roof floors with correct order as it shows below. Click the Generate Random button. You can duplicate it if you want. Select House Example Prefab in the Hierarchy . Press Ctrl-D to duplicate prefab instance in the scene. Change the position on duplicated house by dragging gizmo handle. Click Generate Random button to regenerate it. Repeat. Click a Generate Random button again to randomize look of the house.","title":"How to create a procedural house"},{"location":"tutorials/how-to-create-and-use-a-placeable-object/","text":"How to create and use a Placeable Object \u00b6 A Placeable Object is an object with rules of placing, so you can use it as furniture or some decorating element. Read more: placeable object . How to create \u00b6 To create a Placeable Object select some folder -> right mouse click -> Create -> Domik -> Placeable Object How to configure \u00b6 Click a Find button in the Preview section to zoom to the preview system , it'll allow you to see changes of the Placeable Object . To configure a new Placeable Object , we have to answer three questions: What should it be? Where should it be? Does it need to transform an environment? What should it be? \u00b6 To answer this question we have to select a part that will represent this Placeable Object . In this example we'll use a [0] Venus part. Where should it be? \u00b6 In this example we'll try to place a Venus sculpture in-front of giant mirror somethere in the house. Add some places to the Possible Places list to define there you want to place this object. We'll place Venus in close to the wall and in corners in this example.","title":"how to create and use a placeable object"},{"location":"tutorials/how-to-create-and-use-a-placeable-object/#how-to-create-and-use-a-placeable-object","text":"A Placeable Object is an object with rules of placing, so you can use it as furniture or some decorating element. Read more: placeable object .","title":"How to create and use a Placeable Object"},{"location":"tutorials/how-to-create-and-use-a-placeable-object/#how-to-create","text":"To create a Placeable Object select some folder -> right mouse click -> Create -> Domik -> Placeable Object","title":"How to create"},{"location":"tutorials/how-to-create-and-use-a-placeable-object/#how-to-configure","text":"Click a Find button in the Preview section to zoom to the preview system , it'll allow you to see changes of the Placeable Object . To configure a new Placeable Object , we have to answer three questions: What should it be? Where should it be? Does it need to transform an environment?","title":"How to configure"},{"location":"tutorials/how-to-create-and-use-a-placeable-object/#what-should-it-be","text":"To answer this question we have to select a part that will represent this Placeable Object . In this example we'll use a [0] Venus part.","title":"What should it be?"},{"location":"tutorials/how-to-create-and-use-a-placeable-object/#where-should-it-be","text":"In this example we'll try to place a Venus sculpture in-front of giant mirror somethere in the house. Add some places to the Possible Places list to define there you want to place this object. We'll place Venus in close to the wall and in corners in this example.","title":"Where should it be?"},{"location":"tutorials/how-to-create-and-use-the-pipeline/","text":"How to create and use the Pipeline asset \u00b6 To create a new Pipeline asset right click on some folder -> Create -> Domik -> Pipeline. Create pipeline process To start working with it open it by double clicking Opening pipeline process Now you see the Pipeline window. It's empty and useless. To make it little bit useful right click somethere -> Add Node -> Flow -> Start Start node adding process Drag pin right and release it -> Add -> Add Part Add Part node Drag pin right and release it -> Type \"End\" to the search -> End End node adding process Click Part field in the Add Part node and select Floor part select floor part Save and close the window save and close Now drag this Pipeline to some House Generator pipeline field and click Generate button drag and click generate Here is the result. No, that's not looks like a good place to live, but, at least, now you understand how to works with the Pipeline. To revert changes just select previous Pipeline Select previous pipeline and check it","title":"how to create and use the pipeline"},{"location":"tutorials/how-to-create-and-use-the-pipeline/#how-to-create-and-use-the-pipeline-asset","text":"To create a new Pipeline asset right click on some folder -> Create -> Domik -> Pipeline. Create pipeline process To start working with it open it by double clicking Opening pipeline process Now you see the Pipeline window. It's empty and useless. To make it little bit useful right click somethere -> Add Node -> Flow -> Start Start node adding process Drag pin right and release it -> Add -> Add Part Add Part node Drag pin right and release it -> Type \"End\" to the search -> End End node adding process Click Part field in the Add Part node and select Floor part select floor part Save and close the window save and close Now drag this Pipeline to some House Generator pipeline field and click Generate button drag and click generate Here is the result. No, that's not looks like a good place to live, but, at least, now you understand how to works with the Pipeline. To revert changes just select previous Pipeline Select previous pipeline and check it","title":"How to create and use the Pipeline asset"},{"location":"tutorials/how-to-replace-models-or-materials/","text":"How to replace models or materials \u00b6 If you want to change some part of the house, you have to change its Part Builder in the Skin . Skin is a container of objects with Part Builder components, which are visual representations of parts of the house. Read more: skin , part builder . Usually the house generator uses two groups of skins: House skins - contains part builders for facades , roof and so on. Interior skins - contains part builders for rooms objects: internal walls , furniture , ceiling , floor , etc. House skins contain default look of objects too. If there is no interior for the room, but this room contains a chair, the chair will be constructed by the Part Builder from some House skin . The same if no one interior skin contains a Part Builder for this Part . If house skins and interior skins don't contain a Part Builder for this Part , it'll not be builded at all. To change a look of the room, you have to change skins of an Interior that has been applied to this room. If there is no Interior for this room, you can find this skin in the House skins list . To change some basic part of the house like a facade or roof, you can do it by changing some of House skins . Interior skins list House Generator skins list Read more: how the domik builds a house Example of changing of sofa by replacing its model \u00b6 It this example, we'll change a sofa of the Living Room . To do it we have to find and change a skin which contains a Part Builder of the sofa. Note You can change a view of an object just for one Interior , and all rooms with this Interior will have this new look, but other rooms will not. To change a look of some object for all rooms, you should change it in all skins with this part of the house. Open a Furniture Origin Skin Select [auto] Chilling Section Small Remove sofa models. Add new model as a child of the [auto] Chilling Section Small game object. Fix the position. Close a prefab workspace. Re-generate the house . Example of changing of sofa by overriding its skin \u00b6 Another interesting way to replace something is skins overriding. To find out that does it mean, let's select some interior. Take a closer look at the Skins section . It's a list of skins for this interior . Order of skins is important, top skins have higher priority than down, so you can create a new skin , add sofa to it and place it in the top of skins list. In the result, this sofa will be overridden by new. Create a prefab. Add a Skin component to this prefab. Open this prefab. Create an empty GameObject . Name it exactly as object that you want to replace. Add a Part Builder component to this object. Reset it's position. Place new model as a child of this GameObject . Fix the position Click an Update Binding button in the Skin component in the prefab root. Close a prefab workspace and select an interior . Add this skin in the top of the skins list. Regenerate the house.","title":"how to replace models or materials"},{"location":"tutorials/how-to-replace-models-or-materials/#how-to-replace-models-or-materials","text":"If you want to change some part of the house, you have to change its Part Builder in the Skin . Skin is a container of objects with Part Builder components, which are visual representations of parts of the house. Read more: skin , part builder . Usually the house generator uses two groups of skins: House skins - contains part builders for facades , roof and so on. Interior skins - contains part builders for rooms objects: internal walls , furniture , ceiling , floor , etc. House skins contain default look of objects too. If there is no interior for the room, but this room contains a chair, the chair will be constructed by the Part Builder from some House skin . The same if no one interior skin contains a Part Builder for this Part . If house skins and interior skins don't contain a Part Builder for this Part , it'll not be builded at all. To change a look of the room, you have to change skins of an Interior that has been applied to this room. If there is no Interior for this room, you can find this skin in the House skins list . To change some basic part of the house like a facade or roof, you can do it by changing some of House skins . Interior skins list House Generator skins list Read more: how the domik builds a house","title":"How to replace models or materials"},{"location":"tutorials/how-to-replace-models-or-materials/#example-of-changing-of-sofa-by-replacing-its-model","text":"It this example, we'll change a sofa of the Living Room . To do it we have to find and change a skin which contains a Part Builder of the sofa. Note You can change a view of an object just for one Interior , and all rooms with this Interior will have this new look, but other rooms will not. To change a look of some object for all rooms, you should change it in all skins with this part of the house. Open a Furniture Origin Skin Select [auto] Chilling Section Small Remove sofa models. Add new model as a child of the [auto] Chilling Section Small game object. Fix the position. Close a prefab workspace. Re-generate the house .","title":"Example of changing of sofa by replacing its model"},{"location":"tutorials/how-to-replace-models-or-materials/#example-of-changing-of-sofa-by-overriding-its-skin","text":"Another interesting way to replace something is skins overriding. To find out that does it mean, let's select some interior. Take a closer look at the Skins section . It's a list of skins for this interior . Order of skins is important, top skins have higher priority than down, so you can create a new skin , add sofa to it and place it in the top of skins list. In the result, this sofa will be overridden by new. Create a prefab. Add a Skin component to this prefab. Open this prefab. Create an empty GameObject . Name it exactly as object that you want to replace. Add a Part Builder component to this object. Reset it's position. Place new model as a child of this GameObject . Fix the position Click an Update Binding button in the Skin component in the prefab root. Close a prefab workspace and select an interior . Add this skin in the top of the skins list. Regenerate the house.","title":"Example of changing of sofa by overriding its skin"},{"location":"tutorials/palettes-workflow/","text":"Palettes workflow \u00b6 The Palette - is a tool to randomize a look of house objects. We'll create two palettes for a facade in this tutorial: dark and light, and then we'll use them to create a palettes random container . To create a palette you have to right click on some folder -> Create -> Domik -> Palette Now we have to change a layout of windows to make work comfortable. We need two locked inspectors , one for the house generator to regenerate a house without selecting it in the hierarchy, and the second for palette to make changes without a risk of closing it accidentally. Now we have to add this palette in top of the skins list in the house generator to see the result of palette changes. The facade of the house is split to five groups: Regular facade walls Thin facade walls Thick facade walls Plinth Columns Regular Walls Thin Walls Thick Walls Plinth Columns Now let's add skins for regular walls of the house. This is a dark palette , so we have to select dark skins . Now we'll select skins which looks good enough. We have to divide a list of skins with an empty element, and then group suitable skins under it. Skins list Skins to check Divider Suitable skins Don't forget to set the Debug checkbox to true to use the first element in the skins list, otherwise a random skin will be used. Now let's check the result. Now we have to randomize facade thin walls. Create new skins random group and fill it with thin facade skins . Check the result. Now let's do thick walls. And check the result. Next, let's do the same for the light facade group. Checkout the result. Final step - create a palettes random container to random select one of two palettes.","title":"palettes workflow"},{"location":"tutorials/palettes-workflow/#palettes-workflow","text":"The Palette - is a tool to randomize a look of house objects. We'll create two palettes for a facade in this tutorial: dark and light, and then we'll use them to create a palettes random container . To create a palette you have to right click on some folder -> Create -> Domik -> Palette Now we have to change a layout of windows to make work comfortable. We need two locked inspectors , one for the house generator to regenerate a house without selecting it in the hierarchy, and the second for palette to make changes without a risk of closing it accidentally. Now we have to add this palette in top of the skins list in the house generator to see the result of palette changes. The facade of the house is split to five groups: Regular facade walls Thin facade walls Thick facade walls Plinth Columns Regular Walls Thin Walls Thick Walls Plinth Columns Now let's add skins for regular walls of the house. This is a dark palette , so we have to select dark skins . Now we'll select skins which looks good enough. We have to divide a list of skins with an empty element, and then group suitable skins under it. Skins list Skins to check Divider Suitable skins Don't forget to set the Debug checkbox to true to use the first element in the skins list, otherwise a random skin will be used. Now let's check the result. Now we have to randomize facade thin walls. Create new skins random group and fill it with thin facade skins . Check the result. Now let's do thick walls. And check the result. Next, let's do the same for the light facade group. Checkout the result. Final step - create a palettes random container to random select one of two palettes.","title":"Palettes workflow"},{"location":"tutorials/what-is-a-part-builder-space/","text":"","title":"what is a part builder space"}]}